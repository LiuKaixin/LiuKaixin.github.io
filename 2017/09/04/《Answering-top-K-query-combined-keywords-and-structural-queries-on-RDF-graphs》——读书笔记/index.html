<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="2017年9月," />





  <link rel="alternate" href="/atom.xml" title="三省" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="ABSTRACT虽然SPARQL是RDF图上优越的查询语言，但一些查询意图仍无法使用SPARQL句法表达。关键词搜索虽然能够直观表示信息的需求，但表达准确度较低。为了综合两者的优点，提出了混合查询SK query，并使用基于结构化索引的新型查询算法加速查询。为了更进一步提高SK查询的效率还使用了基于距离的优化技术。 1. Introduction目前RDF图十分流行，图1是Yago知识图谱的一个例">
<meta name="keywords" content="2017年9月">
<meta property="og:type" content="article">
<meta property="og:title" content="《Answering top-K query combined keywords and structural queries on RDF graphs》——读书笔记">
<meta property="og:url" content="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/09/04/《Answering-top-K-query-combined-keywords-and-structural-queries-on-RDF-graphs》——读书笔记/index.html">
<meta property="og:site_name" content="三省">
<meta property="og:description" content="ABSTRACT虽然SPARQL是RDF图上优越的查询语言，但一些查询意图仍无法使用SPARQL句法表达。关键词搜索虽然能够直观表示信息的需求，但表达准确度较低。为了综合两者的优点，提出了混合查询SK query，并使用基于结构化索引的新型查询算法加速查询。为了更进一步提高SK查询的效率还使用了基于距离的优化技术。 1. Introduction目前RDF图十分流行，图1是Yago知识图谱的一个例">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig1.png">
<meta property="og:image" content="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig2-3.png">
<meta property="og:image" content="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig5.png">
<meta property="og:image" content="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig6.png">
<meta property="og:image" content="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/alg1.png">
<meta property="og:image" content="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/alg2.png">
<meta property="og:image" content="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig8.png">
<meta property="og:image" content="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig7.png">
<meta property="og:image" content="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig9.png">
<meta property="og:image" content="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig10.png">
<meta property="og:image" content="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/alg3.png">
<meta property="og:image" content="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/table3.png">
<meta property="og:image" content="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/table4-5.png">
<meta property="og:image" content="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/table9-10.png">
<meta property="og:image" content="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/table11-13.png">
<meta property="og:updated_time" content="2017-10-12T14:05:35.888Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《Answering top-K query combined keywords and structural queries on RDF graphs》——读书笔记">
<meta name="twitter:description" content="ABSTRACT虽然SPARQL是RDF图上优越的查询语言，但一些查询意图仍无法使用SPARQL句法表达。关键词搜索虽然能够直观表示信息的需求，但表达准确度较低。为了综合两者的优点，提出了混合查询SK query，并使用基于结构化索引的新型查询算法加速查询。为了更进一步提高SK查询的效率还使用了基于距离的优化技术。 1. Introduction目前RDF图十分流行，图1是Yago知识图谱的一个例">
<meta name="twitter:image" content="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/09/04/《Answering-top-K-query-combined-keywords-and-structural-queries-on-RDF-graphs》——读书笔记/"/>





  <title>《Answering top-K query combined keywords and structural queries on RDF graphs》——读书笔记 | 三省</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">三省</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">吾日三省吾身</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/09/04/《Answering-top-K-query-combined-keywords-and-structural-queries-on-RDF-graphs》——读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘凯鑫">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/touxiang.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三省">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《Answering top-K query combined keywords and structural queries on RDF graphs》——读书笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-04T20:36:00+08:00">
                2017-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/论文笔记/" itemprop="url" rel="index">
                    <span itemprop="name">论文笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h1><p>虽然SPARQL是RDF图上优越的查询语言，但一些查询意图仍无法使用SPARQL句法表达。关键词搜索虽然能够直观表示信息的需求，但表达准确度较低。为了综合两者的优点，提出了混合查询SK query，并使用基于结构化索引的新型查询算法加速查询。为了更进一步提高SK查询的效率还使用了基于距离的优化技术。</p>
<h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>目前RDF图十分流行，图1是Yago知识图谱的一个例子。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig1.png"><br>SPARQL基于子图匹配，是查询RDF数据的标准方法。但是由于用户不了解RDF的schema，所以查询的实体和谓词并不能和数据库中対映。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig2-3.png"><br>关键词查询是说明信息需求更直观的方法，但也常得到一些无意义的答案。<br>因此本文结合两者的优点提出SK query，其结果是最接近所有关键词的k个SPARQL结果。我们假设关系的强度依赖于路径长度，另外不同的谓词也应该有不同的权重。<br>该问题的另一个挑战是搜索效率，穷举法的流程如下：    </p>
<ol>
<li>用现有技术找出所有匹配的子图。</li>
<li>计算匹配子图和包含关键词的点间的最短路径。</li>
<li>找到路径最短的作为答案。</li>
</ol>
<p>但该方法太低效，我们为SPARQL查询Q设计了一个下限以尽早结束搜索，另外为结构化剪枝提出一个星型索引。提出一个基于距离的优化加速最短路径距离的计算——选择一些中心点，并使最短路径树以这些点为根；如果搜索到了中心点p，则可以使用根在p的最短路径减少搜索空间。<br>本文贡献：</p>
<ol>
<li>提出一个新的查询模式——SK query，结合了SPARQL和关键词，并提供了解决方法。</li>
<li>提出星型索引并实现最短路径树（基于距离的优化）以减少搜索空间和提高查询性能。</li>
<li>实验。</li>
</ol>
<h1 id="2-Background"><a href="#2-Background" class="headerlink" title="2. Background"></a>2. Background</h1><h2 id="2-1-Preliminaries"><a href="#2-1-Preliminaries" class="headerlink" title="2.1 Preliminaries"></a>2.1 Preliminaries</h2><blockquote>
<p><strong>Definition 2.1. </strong> An RDF data graph G is denoted as &lt; V(G), E(G), L&gt;, where (1) $V(G)= V_L \cup V_E \cup V_C$ is the set of vertices in RDF graph G ($V_L,\, V_E,\, V_C$ denote literal, entity and class vertices); (2) E(G) is the set of edges in G; and (3) L is a finite set of edge labels, i.e. predicates.<br><strong>Definition 2.2. </strong> An SK query is a pair &lt; Q,q&gt;, where Q is a SPARQL query graph, and q is a set of keywords $\{w_1,w_2,…,w_n\}$.</p>
</blockquote>
<p>对于SK query &lt; Q,q&gt;，查询结果是$&lt; M,\{ v_1,v_2,…,v_n\} >$, 其中M是Q的子图匹配，$v_i$是包含关键词$w_i$的literal vertex。</p>
<blockquote>
<p><strong>Definition 2.3.</strong> Given a result $r=&lt; M,\{v_1,v_2,…,v_n\}&gt;$, the cost of r is defined as follows:    </p>
<p><script type="math/tex">Cost(r) =Cost_{content}(r)+Cost_{structure}(r)</script>.<br><strong>Definition 2.4.</strong> Given a result <script type="math/tex">r=< M,\{v_1,v_2,...,v_n\}></script>, the content cost of r is defined as follows:    </p>
<p><script type="math/tex">Cost_{content}(r)=\sum^{i=n}_{i=1}C(v_i,w_i)</script>,<br>where $C(v_i,w_i)$ is the matching cost between $v_i$ and keyword $w_i$.</p>
</blockquote>
<p>结构成本只考虑SPARQL查询中的变量——理由: 用户更感兴趣。（我感觉这并不科研）</p>
<blockquote>
<p><strong>Definition 2.5.</strong> Given a result <script type="math/tex">r=< M,\{v_1,v_2,...,v_n\}></script>, the distance between match M and vertex <script type="math/tex">v_i</script> is defined as follows:    </p>
<script type="math/tex; mode=display">d(M,v_i)=MIN_{v\in M}\{d(v,v_i)\}</script><p>其中v是M中和SPARQL查询中某个变量相关的点$ d( v, v_i ) $是v和G中$v_i $的最短距离。结果r的结构成本：<br>$Cost_{content}(r)=\sum^{i=n}_{i=1} C(v_i,w_i) $</p>
</blockquote>
<p>(<strong>Problem Definition</strong>) Given an SK query &lt;Q,q&gt; and parameter k, our problem is to find the k results that have the k-smallest costs.</p>
<h2 id="2-2-Predicate-salience"><a href="#2-2-Predicate-salience" class="headerlink" title="2.2 Predicate salience"></a>2.2 Predicate salience</h2><p>本文使用最短路径距离评估关系强度。一般的最短路径距离不区分谓词，把”type”、”label”等和普通谓词同等看待不合理。因此引入了predicate salience：    <script type="math/tex">ps(p)=\frac{|V(p)|}{|V(G)|}</script></p>
<h1 id="3-Overview"><a href="#3-Overview" class="headerlink" title="3. Overview"></a>3. Overview</h1><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig5.png">
<p><strong>Keyword Mapping.</strong> 离线时，为每个关键词建立倒排列表。在线时，根据倒排列表获取关键词对应的节点。对于关键词节点，在给定查询上的常用度量是TF/IDF成本。参考文献中有很多成本函数，我们选择其中一种计算包含关键字的节点的成本。<br>本文中主要关心如何找到SPARQL的匹配以及和关键词之间的关系。我们使用现有的IR引擎分析给定的关键词，并执行不精确匹配得到一些语法或语义相似的元素。<br><strong>Candidate Generation. </strong>如果找到能到达所有关键词的节点，则需要使用子图同态检查SPARQL的子图匹配是否包含该点。此步采用“filter-and-refine”策略，首先找到一些没有在任何Q的子图匹配中出现的dummy节点，如果搜索到dummy节点则不执行子图同态。<br>本文提出一种frequent star pattern-based structural index。基于该索引可以为SPARQL查询的变量提供候选列表。<br><strong>Top-k Results Computation. </strong>基于图搜索，循环地计算关键词节点与邻居的距离，找到一个能达到所有关键词的节点，如果不是dummy vertex，则使用SPARQL matching算法。</p>
<h1 id="4-Candidate-generation-based-on-the-structural-index"><a href="#4-Candidate-generation-based-on-the-structural-index" class="headerlink" title="4. Candidate generation based on the structural index"></a>4. Candidate generation based on the structural index</h1><h2 id="4-1-Structural-index"><a href="#4-1-Structural-index" class="headerlink" title="4.1 Structural index"></a>4.1 Structural index</h2><p>本节提出一个frequent star pattern-based index。从G中挖掘出一些常见的星型模式，并为每个星型模式建立一个节点的倒排列表。选择星型的原因是在SPARQL查询常包含星型子查询。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig6.png"><br>如表2，每个实体的谓词以字典序存储，如图6，sequential pattern和star pattern一一对应，使用现有的sequential pattern挖掘算法，如PrefixSpan来挖掘星型模式。</p>
<p>我们不能为每个星型模式建立目录，因此我们我们定义了discriminative ratio。L(S)={v|S occurs in v’s adjacent edge seuence}即返回符合星型模式S的所有点v。</p>
<blockquote>
<p><strong>Definition 4.1. </strong>Given a star S, its discriminative ratio is defined as follows:<br>$\gamma (S)=\frac{|L(S)|}{|\cap_{S^{‘}\subset S} \,\,L(S^{‘})|}$</p>
</blockquote>
<p>如果$\gamma (S)$越大，则说明如果保存S的子集作为目录元素的话，就没必要保存S作为目录元素。因此设定$\gamma (S)\le \gamma_{max}$。但对于只有一条边的星型查询，我们始终将其放入目录中。</p>
<blockquote>
<p><strong>Theorem 4.1. </strong> Let F denote all selected index elements (i.e., frequent star patterns). Given a SPARQL query Q, a vertex v in graph G can be pruned (there exists no subgraph match of Q containing v) if the following equation holds.<br>$v\notin \cup_{S\in F \land S \in Q}L(S)$,<br>where $S\in F$ means that S is a selected star pattern and $S\in Q$ is a star pattern included in Q.<br>定义剪枝策略，如果该点不在查询的子结构中，则剪枝。</p>
</blockquote>
<h2 id="4-2-Candidate-generation"><a href="#4-2-Candidate-generation" class="headerlink" title="4.2 Candidate generation"></a>4.2 Candidate generation</h2><p>先依据Theorem 4.1剪枝掉不可能的点，然后根据变量的predicate sequence在索引找中找到候选点。</p>
<blockquote>
<p><strong>Definition 4.2. Dummy Vertex.</strong> Given a SPARQL query Q, a vertex v in graph G is called a dummy vertex if the following equation holds.<br>$v\notin \cup_{S\in F \land S \in Q}L(S)$,<br>where F denotes all selected frequent star patterns, $S\in F$ means that S is a selected star pattern and $S\in Q$ is a star pattern included in Q.</p>
</blockquote>
<p>搜索时，如果v不是dummy vertex，则执行子图同态算法找到包含v的SPARQL查询的匹配结果。</p>
<h1 id="5-Top-k-results-computation"><a href="#5-Top-k-results-computation" class="headerlink" title="5. Top-k results computation"></a>5. Top-k results computation</h1><h2 id="5-1-Graph-exploration"><a href="#5-1-Graph-exploration" class="headerlink" title="5.1 Graph exploration"></a>5.1 Graph exploration</h2><p>目的是找到图中与关键词节点相联系的节点并计算距离。</p>
<blockquote>
<p><strong>Definition 5.1 Distance between a Vertex and Keyword.</strong> Given a vertex v in RDF graph G and a keyword $w_i$, the distance between v and keyword $w_i$ (denoted as $d(v,w_i)$) is the minimum distance between v and a vertexin $V_i$, where $V_i$ includes all literal vertices containing keyword $w_i$ in G.</p>
</blockquote>
<img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/alg1.png">
<p>对每个关键词遍历，然后对于关键词k所在的优先队列使用bfs，搜索邻居，并更新相关变量。</p>
<blockquote>
<p><strong>Theorem 5.1.</strong> When a queue head (v,p,|p|) is poped from queue $PQ_i$, the following equation holds.<br>$d(v,w_i)=d[v][i]=|p|$</p>
<p><strong>Definition 5.2. Seen by a Keyword.</strong> When queue head (v,p,|p|) is popped from queue $PQ_i$, the distance between v and keyword $w_i$ has been computed. We then say that vertex is <em>seen</em> by keyword $w_i$.<br>**Definition 5.3. Fully Seen Vertex, Partially Seen Vertex, and Unseen Vertex.</p>
</blockquote>
<h2 id="5-2-Generatinon-of-SPARQl-matches"><a href="#5-2-Generatinon-of-SPARQl-matches" class="headerlink" title="5.2. Generatinon of SPARQl matches"></a>5.2. Generatinon of SPARQl matches</h2><p>找到fully seen vertex v，下一步是计算包含v的SPARQL匹配。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/alg2.png"><br>如算法2所示，我们使用基于DFS的状态转移算法，从fully seen vertex v开始进行匹配处理，对于已经处理过的节点v，因为包含该点的答案都已经得到，所以在处理其他节点时，跳过该点，如图8。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig8.png"></p>
<blockquote>
<p><strong>Definition 5.4.</strong> Given a SPARQL query graph Q with m vertices $u_1,…u_m$, a state is a (partial) match of query graph Q.</p>
</blockquote>
<img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig7.png">
<h2 id="5-3-Top-k-computation"><a href="#5-3-Top-k-computation" class="headerlink" title="5.3. Top-k computation"></a>5.3. Top-k computation</h2><p>把所有节点计算后，然后取出top-k的答案，太低效，本节设计了early-stop strategy。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig9.png"></p>
<blockquote>
<p><strong>Definition 5.5. Fully Seen Match, Partially Seen Match and Unseen Match.</strong> Given a subgraph match M of SPARQl query Q, if all vertices in M are fully seen vertices, M is called a fully seen match; if M is not a fully seen match and M contains at least one fully seen vertex, it is called a partially seen match. If a match M does not contain any fully seen vertex, it is valled an unseen match.</p>
</blockquote>
<p>early-stop strategy：只计算fully seen mateches 的成本，以k-th小的成本作为阈值$\delta$并且计算partially seen matches和unseen matches的下限$\theta_1$和$\theta_2$，当且仅当$\delta &lt;\theta_1 \land\delta &lt;\theta_2$时，提前停止。否则，继续下一轮迭代。</p>
<h3 id="Fully-Seen-Match"><a href="#Fully-Seen-Match" class="headerlink" title="Fully Seen Match."></a><strong>Fully Seen Match.</strong></h3><p>按照Definition 2.5计算成本，并维护阈值$\delta$。</p>
<h3 id="Partially-Seen-Match"><a href="#Partially-Seen-Match" class="headerlink" title="Partially Seen Match."></a><strong>Partially Seen Match.</strong></h3><p>按以下方式计算下界。</p>
<blockquote>
<p><strong>Theorem 5.2.</strong> Given a partially seen match M of SPARQL query Q, v is a partially seen or an unseen vertex in the match. The following equation holds.<br>$Cost(M)=\sum_{1\le i\le n}d(v,w_i)\ge \sum_{d[v] [w_i]\ne null\land 1\le i\le n}d[v] [w_i] +\sum_{d[v][w_i]= null\land 1\le i\le n}|p_i|$<br>where $[v][w_i]$is the i-th dimension of v’s vector corresponding to keyword $w_i$, and $|p_i|$ corresponds to the current queue head $(v,p_i,|p_i|)$ in queue $PQ_i$</p>
</blockquote>
<p>依据Theorem 5.2，a partially seen match M的下界为：</p>
<blockquote>
<p><strong>Definition 5.6</strong> Given a match M of SPARQL query Q, the lower bound of a partially seen match M is defined as follows.<br>$lb(M)=MIN_{v\in M} (\sum_{d[v] [w_i]\ne null\land 1\le i\le n}d[v] [w_i] +\sum_{d[v][w_i]= null\land 1\le i\le n}|p_i|)$</p>
</blockquote>
<p>所有partially seen matches的下界为：</p>
<blockquote>
<p><strong>Definition 5.7</strong> The lower bound $\theta_1$ for all partially seen matches is as follows.<br>$\theta_1=MIN_{M\in PS}(lb(M))$<br>where PS denotes all partially seen matches.</p>
</blockquote>
<p>在迭代过程中，一些partially seen matches变成了fully seen matches，阈值$\delta$和$\theta_1$也随之更新。</p>
<h3 id="Unseen-Match"><a href="#Unseen-Match" class="headerlink" title="Unseen Match."></a>Unseen Match.</h3><p>包含两种点：Partially seen Vertex、 Unseen Vertex.</p>
<blockquote>
<p><strong>Theorem 5.3.</strong> For an unseen vertex v, if threshold $\delta\ne \infty$, the following equation holds.<br>$\delta \le \Sigma_{1\le i\le n}d(v,w_i)$</p>
</blockquote>
<p>按照Theorem 5.3，unseen match的下限没必要考虑unseen matches。</p>
<blockquote>
<p><strong>Definition 5.8. </strong> The lower bound $\theta_2$ for all unseen matches is as follows.<br>$\theta_2=MIN_{v\in PSet}(\sum_{d[v] [w_i]\ne null\land 1\le i\le n}d[v] [w_i] +\sum_{d[v][w_i]= null\land 1\le i\le n}|p_i|),$<br>where PSet contains all partially seen vertices, $d[v][w_i]$ is the i-th dimension of v’s vector corresponding to keyword $w_i$ and $|p_i|$ corresponds to the current queue head $(v, p_i, |p_i|)$ in queue $PQ_i$.</p>
</blockquote>
<h3 id="Early-stop-Strategy"><a href="#Early-stop-Strategy" class="headerlink" title="Early-stop Strategy."></a>Early-stop Strategy.</h3><p>在每次迭代中，都检查$\delta\le \theta_1 \land \delta \le \theta_2$.如果条件成立，则算法停止。</p>
<h1 id="6-Distance-based-optimization"><a href="#6-Distance-based-optimization" class="headerlink" title="6. Distance-based optimization"></a>6. Distance-based optimization</h1><p>算法1使用后向搜索遍历RDF图，为加快搜索，我们提出了pivot-based distance index. 离线时选中一些点作为pivots，预先计算根在pivot的路径，搜索时如果遇到pivot，则利用预存的距离信息，减少搜索空间。</p>
<h2 id="6-1-Pivot-based-search-for-top-k-results-of-SK-queries"><a href="#6-1-Pivot-based-search-for-top-k-results-of-SK-queries" class="headerlink" title="6.1 Pivot-based search for top-k results of SK queries"></a>6.1 Pivot-based search for top-k results of SK queries</h2><blockquote>
<p><strong>Definition 6.1.</strong> Given a shortest path tree T rooted at vertex r (denoted as T(r)), pivot p, and vertex v, if the shortest path between r and v crosses pivot p, we say that v is covered by p in T.<br><strong>Theorem 6.1.</strong> if v is covered by p in the shortest path tree T(r), d(r,v)=d(r,p)+d(p,v) where d(r,v) denotes the shortest path distance between r and v.</p>
</blockquote>
<p>如图10，T(015)中的点001被pivotcover，d(015,001)=d(015,017)+d(017,001)=2.222.<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig10.png"></p>
<img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/alg3.png">
<p>7-17行和18-20行与算法1的对比。</p>
<h2 id="6-2-Pivot-selection"><a href="#6-2-Pivot-selection" class="headerlink" title="6.2 Pivot selection"></a>6.2 Pivot selection</h2><blockquote>
<p><strong>Definition 6.2.</strong> Given a shortest path tree T(v) rooted at v and a set of pivots PV, the covered ratio is </p>
<script type="math/tex; mode=display">cr(T(v))=\frac{|\{v^{'}|v^{'}\,\, is\,\,covered\,\, by\,\, p\,\, in\,\, T\,\,and\, \,p\,\, \in\, \,PV\}|}{|V(G)|}</script><p><strong>Theorem 6.2.</strong> Given a constant M, finding a pivot set PV to maximize $(\sum_{v\in V(G)}cr(T(v)))$ is a NP-hard problem, where |PV|=M and T(v) denotes the shortest path tree rooted at v.</p>
</blockquote>
<p>因此使用一些启发式选择pivots——a high-degree strategy.</p>
<h2 id="6-3-Further-optimization"><a href="#6-3-Further-optimization" class="headerlink" title="6.3 Further optimization"></a>6.3 Further optimization</h2><p>后期大部分路径都被计算出来，没必要再去load pivot的最短路径树，因此提供了一个终止loading的条件。<br>$Cost_{update}=Count_{update}\times Cost_{CPU}$<br>where $Cost_{CPU}$ is the average CPU cost of a distance update operation.<br>$Cost_{I/O}$ is the average I/O cost of a distance update operation.<br>1) if $Cost_{update}\le Cost_{I/O}$，continue to load pivot’s shortest path tree.<br>2) if $Cost_{update}&gt; Cost_{I/O}$，end loading pivot’s shortest path tree.<br>其中$Cost_{CPU}$和$Cost_{I/O}$是常数。</p>
<h1 id="7-Experiments"><a href="#7-Experiments" class="headerlink" title="7. Experiments"></a>7. Experiments</h1><p>数据集：DBLP,Yago,DBPedia.<br>Baseline:<br>    (Effectiveness)BANKS,BANKS,Annotated SPARQL.（分别对应三个数据集）<br>    (Efficiency) exhaustive computing（第一节有提到）, Basic Search(Algorithm 1), Pivot-based Search(Algorithm 3)</p>
<h2 id="7-1-Datasets-and-setup"><a href="#7-1-Datasets-and-setup" class="headerlink" title="7.1 Datasets and setup"></a>7.1 Datasets and setup</h2><p>Our experiments were conducted on a machine with a 2.4 Ghz Core 2 Duo processor and 80G RAM memory.</p>
<h2 id="7-2-Effectiveness-study"><a href="#7-2-Effectiveness-study" class="headerlink" title="7.2 Effectiveness study"></a>7.2 Effectiveness study</h2><h3 id="7-2-1-Case-Study"><a href="#7-2-1-Case-Study" class="headerlink" title="7.2.1 Case Study"></a>7.2.1 Case Study</h3><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/table3.png">
<img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/table4-5.png">
<h3 id="7-2-2-NDCG-k-over-Yago-and-DBLP"><a href="#7-2-2-NDCG-k-over-Yago-and-DBLP" class="headerlink" title="7.2.2. NDCG@k over Yago and DBLP"></a>7.2.2. NDCG@k over Yago and DBLP</h3><p>NDCG——the normalized discounted cumulative gain。</p>
<h3 id="7-2-3-MAP-over-Yago-and-DBLP"><a href="#7-2-3-MAP-over-Yago-and-DBLP" class="headerlink" title="7.2.3. MAP over Yago and DBLP"></a>7.2.3. MAP over Yago and DBLP</h3><p>MAP——the mean average precision.<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/table9-10.png"></p>
<h2 id="7-3-Efficiency-study"><a href="#7-3-Efficiency-study" class="headerlink" title="7.3. Efficiency study"></a>7.3. Efficiency study</h2><h3 id="7-3-1-Pruning-effect-of-the-structure-index"><a href="#7-3-1-Pruning-effect-of-the-structure-index" class="headerlink" title="7.3.1. Pruning effect of the structure index."></a>7.3.1. Pruning effect of the structure index.</h3><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/table11-13.png">
<h3 id="7-3-2-Evaluation-of-pivot-selection-methods"><a href="#7-3-2-Evaluation-of-pivot-selection-methods" class="headerlink" title="7.3.2. Evaluation of pivot selection methods"></a>7.3.2. Evaluation of pivot selection methods</h3><h3 id="7-3-3-Evaluation-of-pivot-numbers"><a href="#7-3-3-Evaluation-of-pivot-numbers" class="headerlink" title="7.3.3. Evaluation of pivot numbers"></a>7.3.3. Evaluation of pivot numbers</h3><h3 id="7-3-4-Offline-performance"><a href="#7-3-4-Offline-performance" class="headerlink" title="7.3.4. Offline performance"></a>7.3.4. Offline performance</h3><h3 id="7-3-5-Online-performance"><a href="#7-3-5-Online-performance" class="headerlink" title="7.3.5. Online performance"></a>7.3.5. Online performance</h3><h1 id="8-Related-work"><a href="#8-Related-work" class="headerlink" title="8. Related work"></a>8. Related work</h1><ul>
<li>SPARQL查询。一些把RDF存储在RDBMS，用join操作回应SPARQL查询。RDF-3x和Hexastore为主谓宾分别创建索引。gStore和AmbER在RDF图中利用子图匹配应答SPARQL，和VF2应答SPARQL查询类似。</li>
<li>关键词查询。<ul>
<li>将关键词转换为SPARQL，然后利用SPARQL查询引擎。</li>
<li>找到包含所有关键词的子结构，如tree，clique，或其他。</li>
</ul>
</li>
<li>挖掘常用pattern建立索引。gIndex，gSpan，GADDI。</li>
<li>keyword和SPARQL的混合查询。Elbassuoni假定每个三元组都有相联系的文字段落，利用关键词条件扩展SPARQL中的三元组。$CE^2$假定每个资源都有联系的文档，他用关键词条件扩展SPARQL中的变量。但本方法适用范围最广。</li>
<li>其他。[38]中作者为结构化查询中掺杂关键词查询定义了新的查询语言。Bhagdev和Bikakis尝试使用语义进行关键词查询，邹蕾将自然语言转换成SPARQL查询（读过）。<h1 id="9-Conclusions"><a href="#9-Conclusions" class="headerlink" title="9. Conclusions"></a>9. Conclusions</h1>In this paper, we proposed a new kind of query (the SK query) that integrates SPARQL and keywords. To handle this kind<br>of query, we first introduced a basic method based on backward search. However, this basic solution faces several performance is- sues. Hence, we built a structural index and a distance-based in- dex. Our structural index is based on frequent star patterns in the RDF data, and our distance-based index is based on the shortest path trees of selected pivots in the RDF graph. Using the indices, we propose an advanced strategy to deal with SK queries. Finally, using three real RDF datasets, we demonstrated that our method can outperform the baseline both with respect to effectiveness and efficiency.</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/2017年9月/" rel="tag"># 2017年9月</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/08/24/《Keyword-Search-in-Graphs-Finding-r-cliques》——读书笔记/" rel="next" title="《Keyword Search in Graphs: Finding r-cliques》——读书笔记">
                <i class="fa fa-chevron-left"></i> 《Keyword Search in Graphs: Finding r-cliques》——读书笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/27/hexo编写博客/" rel="prev" title="hexo博客编写">
                hexo博客编写 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/touxiang.jpg"
               alt="刘凯鑫" />
          <p class="site-author-name" itemprop="name">刘凯鑫</p>
           
              <p class="site-description motion-element" itemprop="description">刘凯鑫的博客，记录所思所想，所学所得。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/3794225512" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                    
                      Weibo
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ABSTRACT"><span class="nav-text">ABSTRACT</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Introduction"><span class="nav-text">1. Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Background"><span class="nav-text">2. Background</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-Preliminaries"><span class="nav-text">2.1 Preliminaries</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-Predicate-salience"><span class="nav-text">2.2 Predicate salience</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Overview"><span class="nav-text">3. Overview</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Candidate-generation-based-on-the-structural-index"><span class="nav-text">4. Candidate generation based on the structural index</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-Structural-index"><span class="nav-text">4.1 Structural index</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-Candidate-generation"><span class="nav-text">4.2 Candidate generation</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Top-k-results-computation"><span class="nav-text">5. Top-k results computation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-Graph-exploration"><span class="nav-text">5.1 Graph exploration</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-Generatinon-of-SPARQl-matches"><span class="nav-text">5.2. Generatinon of SPARQl matches</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-Top-k-computation"><span class="nav-text">5.3. Top-k computation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Fully-Seen-Match"><span class="nav-text">Fully Seen Match.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Partially-Seen-Match"><span class="nav-text">Partially Seen Match.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Unseen-Match"><span class="nav-text">Unseen Match.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Early-stop-Strategy"><span class="nav-text">Early-stop Strategy.</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-Distance-based-optimization"><span class="nav-text">6. Distance-based optimization</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-Pivot-based-search-for-top-k-results-of-SK-queries"><span class="nav-text">6.1 Pivot-based search for top-k results of SK queries</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-Pivot-selection"><span class="nav-text">6.2 Pivot selection</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-Further-optimization"><span class="nav-text">6.3 Further optimization</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-Experiments"><span class="nav-text">7. Experiments</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-Datasets-and-setup"><span class="nav-text">7.1 Datasets and setup</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-Effectiveness-study"><span class="nav-text">7.2 Effectiveness study</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-Case-Study"><span class="nav-text">7.2.1 Case Study</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-NDCG-k-over-Yago-and-DBLP"><span class="nav-text">7.2.2. NDCG@k over Yago and DBLP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-3-MAP-over-Yago-and-DBLP"><span class="nav-text">7.2.3. MAP over Yago and DBLP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-Efficiency-study"><span class="nav-text">7.3. Efficiency study</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-1-Pruning-effect-of-the-structure-index"><span class="nav-text">7.3.1. Pruning effect of the structure index.</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-2-Evaluation-of-pivot-selection-methods"><span class="nav-text">7.3.2. Evaluation of pivot selection methods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-3-Evaluation-of-pivot-numbers"><span class="nav-text">7.3.3. Evaluation of pivot numbers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-4-Offline-performance"><span class="nav-text">7.3.4. Offline performance</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-5-Online-performance"><span class="nav-text">7.3.5. Online performance</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-Related-work"><span class="nav-text">8. Related work</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-Conclusions"><span class="nav-text">9. Conclusions</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘凯鑫</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
