<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三省</title>
  
  <subtitle>吾日三省吾身</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/LiuKaixin/LiuKaixin.github.io/"/>
  <updated>2017-10-28T04:49:46.229Z</updated>
  <id>https://github.com/LiuKaixin/LiuKaixin.github.io/</id>
  
  <author>
    <name>刘凯鑫</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Finding Patterns in a Knowledge Base using Keywords to Compose Table Answers》——论文笔记</title>
    <link href="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/10/28/Finding-Patterns-in-a-Knowledge-Base-using-Keywords-to-Compose-Table-Answers-1/"/>
    <id>https://github.com/LiuKaixin/LiuKaixin.github.io/2017/10/28/Finding-Patterns-in-a-Knowledge-Base-using-Keywords-to-Compose-Table-Answers-1/</id>
    <published>2017-10-28T04:49:35.000Z</published>
    <updated>2017-10-28T04:49:46.229Z</updated>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;test&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《知识图谱构建技术综述》——论文笔记</title>
    <link href="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/10/20/%E3%80%8A%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E6%9E%84%E5%BB%BA%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0%E3%80%8B%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/LiuKaixin/LiuKaixin.github.io/2017/10/20/《知识图谱构建技术综述》——论文笔记/</id>
    <published>2017-10-20T12:43:00.000Z</published>
    <updated>2017-10-22T06:19:39.877Z</updated>
    
    <content type="html"><![CDATA[<p><em>因实验室的项目需要，对跨界服务知识图谱构建技术，进行相关的调研。</em></p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><ol><li>对知识图谱的定义和内涵进行说明，并给出构建知识图谱的技术框架，按照输入的只是素材的抽象程度将其划分为3个层次：信息抽取层、知识融合层和知识加工层。</li><li>分别对每个层次设计的关键技术的研究现状进行分类说明，指出知识图谱与相关学科的关系。</li><li>对知识图谱构建面临的挑战和问题进行总结。</li></ol><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>语义网络是一张数据构成的网络，语义网络技术提供查询环境，以图形的方式返回经过加工和推理的知识。<br>知识图谱则是实现智能化语义检索的基础和桥梁。<br>谷歌开始。<br>中文——知网（HowNet），百度知心，搜狗知立方，清华Xlore，中科院OpenKN，上海交大zhishi.me，复旦GDM实验室的项目。</p><h1 id="1-知识图谱的定义与架构"><a href="#1-知识图谱的定义与架构" class="headerlink" title="1 知识图谱的定义与架构"></a>1 知识图谱的定义与架构</h1><img src="http://ouqbyuben.bkt.clouddn.com/images/知识图谱构建技术综述/table1.png"><h2 id="1-1-知识图谱的定义"><a href="#1-1-知识图谱的定义" class="headerlink" title="1.1 知识图谱的定义"></a>1.1 知识图谱的定义</h2><blockquote><p><strong>定义1.</strong> 知识图谱。是结构化的语义知识库，用于以符号形式描述物理世界中的概念及其互相关系。其基本组成单位是“实体-关系-实体”三元组，以及实体及其相关属性-值对，实体间通过关系相互连接，构成网状的知识结构。</p></blockquote><ol><li>知识图谱是一个具有属性的实体通过关系连接而成的网状知识库。点代表实体，边代表关系，由此知识图谱是对物理世界的一种符号表达。</li><li>研究价值：借助知识图谱，能够在Web网页之上建立概念间的连接关系，从而以最小的代价将互联网中的信息组织起来，成为可以被利用的知识。</li><li>应用价值：改变现有的信息检索方式，一、通过推理实现概念检索（相对于字符串的模糊匹配方式而言）；二、以图形化方式向用户展示经过分类整理的结构化知识，使人们从人工过滤网页寻找答案的模式中解脱出来。<em>（怎么解脱？还不是太懂）</em><h2 id="1-2-知识图谱的架构"><a href="#1-2-知识图谱的架构" class="headerlink" title="1.2 知识图谱的架构"></a>1.2 知识图谱的架构</h2></li></ol><p>知识图谱的逻辑结构：</p><ul><li>数据层：知识以事实为单位存储在图数据中，以三元组的方式从而形成图谱。</li><li>模式层：知识图谱的核心，存储经过提炼的知识，通常采用本地库管理知识图谱的模式层，相当于知识图谱中的模具。<br><strong>构建知识图谱所采用的技术架构</strong><img src="http://ouqbyuben.bkt.clouddn.com/images/知识图谱构建技术综述/fig1.png">虚线中是构建过程，也是图谱更新的过程。详细介绍：如图所示，从原始数据出发，采用自动或半自动的方法，从数据中提取出知识，并存入知识库的数据层和模式层。<br>这是一迭代更新的过程，每次迭代包含3个阶段：信息抽取、知识融合以及知识加工。<br>两种方式：</li><li>自顶而下：借助百科类网站等结构化数据源，从高质量数据中提取本体和模式信息，加入到知识库中；</li><li>自底而上：借助一定的技术手段，从公开采集的数据中提取出资源模式，选择其中置信度较高的新模式，经人工审核之后，加入到知识库中。</li></ul><p>最初自顶而下，现在流行自底而上，这也是本文介绍的重点。</p><h1 id="2-知识图谱的构建技术"><a href="#2-知识图谱的构建技术" class="headerlink" title="2 知识图谱的构建技术"></a>2 知识图谱的构建技术</h1><h2 id="2-1-信息抽取"><a href="#2-1-信息抽取" class="headerlink" title="2.1 信息抽取"></a>2.1 信息抽取</h2><p>从异构数据源中抽取实体，属性和关系，并形成本体化的知识表达。</p><h3 id="2-1-1-实体抽取"><a href="#2-1-1-实体抽取" class="headerlink" title="2.1.1 实体抽取"></a>2.1.1 实体抽取</h3><p>早期面向单一领域：</p><ul><li>规则：耗费人力物力，可扩展性差。</li><li>统计机器学习：单纯基于有监督学习的实体抽取方法效果不理想，且算法性能依赖训练样本的规模。</li><li>两者结合。</li></ul><p>面向开放领域：</p><ul><li>Sekine首先对实体进行分类150种，Ling对实体进行分类112种。</li><li>但预定义分类的方式难以适应时代的需求，采用统计机器学习的方法，从目标集中抽取相似上下文进行实体的分类和聚类。</li><li>如何从少量实体示例中发现具有区分力的模式。<ul><li>迭代拓展实体语料库。</li><li>通过搜索引擎的服务器日志获取新出现的命名实体。</li></ul></li></ul><h3 id="2-1-2-关系抽取"><a href="#2-1-2-关系抽取" class="headerlink" title="2.1.2 关系抽取"></a>2.1.2 关系抽取</h3><p>为得到语义信息，从相关预料中提取实体之间的关系。 </p><ul><li>早期人工构造语法与语义规则，不足：<ul><li>1、要求制定规则的人具有良好的语言学造诣，并且对特定领域有深入的理解与认知。<ul><li>2、规则制定工作量大，难以适应丰富的语言表达风格，且难以扩展到其他领域。</li></ul></li></ul></li><li>统计机器学习方法。<ul><li>基于特征向量或核函数的有监督方法。需要大量标注语料。</li><li>半监督与无监督的学习方式。</li></ul></li></ul><p>为解决需要预先定语实体关系类型的问题：</p><ul><li>Banko提出面向开放域的信息抽取方法框架，首先从少量人工标记数据得到实体关系分类模型，然后对数据进行分类。</li><li>Wu等基于Banko的工作，利用维基百科提供的属性信息，自动构造实体关系训练集。</li></ul><p>现在流行的OIE（Open information extraction）存在两个问题：</p><ul><li>现在只考虑二元实体关系，很少考虑高阶多元实体关系。</li><li>只关注发掘词汇或词组之间的关系模式，而无法实现对隐含语义关系的抽取。</li></ul><h3 id="2-1-3-属性抽取"><a href="#2-1-3-属性抽取" class="headerlink" title="2.1.3 属性抽取"></a>2.1.3 属性抽取</h3><p>定义：从不同信息员中采集特定实体的属性信息。</p><p>由于可将实体的属性视为实体于属性值之间的一种名词性关系，因此也可以将属性抽取问题视为关系抽取问题。</p><ul><li>从结构化或半结构化的百科网站获取大量实体属性数据。</li><li>非结构化的公开数据。<ul><li>基于百科类网站的半结构化数据，通过自动抽取生成训练许了，用于训练实体属性标注模型，然后应用于非结构化数据。</li><li>采用数据挖掘的方法直接从文本中挖掘实体属性与属性值之间的关系模式。</li></ul></li></ul><h2 id="2-2-知识融合"><a href="#2-2-知识融合" class="headerlink" title="2.2 知识融合"></a>2.2 知识融合</h2><p>消除概念的歧义，剔除冗余和错误概念，从而确保知识的质量。</p><h3 id="2-2-1-实体链接"><a href="#2-2-1-实体链接" class="headerlink" title="2.2.1 实体链接"></a>2.2.1 实体链接</h3><p>定义：对从文本中抽取得到的实体对象，将其链接到知识库中对应的正确实体对象的操作。<br>早期：仅关注如何将从文本中抽取到的实体链接到知识库中，忽视了位于统一文档的实体间存在的语义关系。<br>现在：利用实体的共现关系，同时将多个实体链接到知识库中——集成实体链接。</p><p>流程：</p><ol><li>从文本中通过实体抽取得到实体指称项。</li><li>进行实体消歧和共指消解。</li><li>在确认知识库中对应的正确实体对象之后，将该实体指称项链接到知识库中对应实体。</li></ol><h4 id="1-实体消歧"><a href="#1-实体消歧" class="headerlink" title="1) 实体消歧"></a>1) 实体消歧</h4><p>解决同名实体产生歧义问题的技术，通常采用聚类法。<br>聚类法是指以实体对象为聚类中心，将所有指向同一目标实体对象的指称项聚集到以对象为中心的类别下。其关键在于如何定义实体对象和指称项之间的相似度，常用方法有以下四种：</p><ol><li>空间向量模型（词袋模型）。取当前语料中实体指称项周边的词构成特征向量，然后利用向量的余弦相似度进行比较，将该指称项聚类到与之最相近的实体指称项集合中。缺点：没有考虑上下文语义信息。</li><li>语义模型。和空间向量模型类似，区别在于特征向量构造方法不同，语义模型的特征向量不仅包含词袋向量，而且包含一部分语义特征。</li><li>社会网络模型。假设物以类聚，人以群分。建模时，首先利用实体间的关系将与之相关的指称项连接起来构成网络，然后利用社会网络分析技术计算该网络中节点之间的拓扑距离，以此来判定指称项之间的相似度。</li><li>百科知识模型。百科类网站通常会为每个实体（指称项）分配一个单独页面，其中包括指向其他实体页面的超链接，利用这种链接关系来计算实体指称项之间的相似度。但因百科类知识库中实体数有限，此类方法的推广性较差。</li></ol><p>另一个问题如何对存在歧义的实体进行重要性评估，确定推荐内容的优先级。主要解决方法是为实体赋予权重，用于表示该实体出现的频率或先验概率。</p><h4 id="2-共指消解"><a href="#2-共指消解" class="headerlink" title="2) 共指消解"></a>2) 共指消解</h4><p>解决多个指称项对应于同一实体对象的问题。又称为对象对齐、实体匹配以及实体同义。</p><ul><li>基于自然语言处理的方法。以句法分析为基础，代表方法是Hobbs算法和向心理论。<ul><li>Hobbs算法：基于句法分析树进行搜索，适用于实体与代词出现在同一句子中。</li><li>向心理论：将表达模式视为语篇的基本组成单元，通过识别表达模式中的实体，获得当前和后续语篇中的关注中心（实体），根据语义的局部连贯性和显著性，就可以在语篇中跟踪受关注的实体。</li></ul></li><li>统计机器学习。<ul><li>视为分类问题。</li><li>视为聚类问题，以实体指称项为中心通过实体聚类实现指称项与实体对象的匹配。</li><li>主要缺点：训练数据的（特征）稀疏性和难以在不同的概念上下文中建立实体关联。Pantel等提出新的实体相似性测度模型——术语相似度，可从全局语料中得到所有术语间统计意义上的相似性。Chakrabarti将网页点击相似性和文档相似性相结合，提出新的查询上下文相似性测度。</li></ul></li></ul><h3 id="2-2-2-知识合并"><a href="#2-2-2-知识合并" class="headerlink" title="2.2.2 知识合并"></a>2.2.2 知识合并</h3><h4 id="1-合并外部知识库"><a href="#1-合并外部知识库" class="headerlink" title="1) 合并外部知识库"></a>1) 合并外部知识库</h4><ol><li>数据层的融合，包括实体的指称、属性、关系以及所属类别等，主要的温床是如何避免实例以及关系的冲突问题，造成不必要的冗余。</li><li>通过模式层的融合，将新得到的本体融入已有的本体库中。</li></ol><p>关联开放数据项目（linked open data）会定期发布整理的语义知识数据，如DBpedia，YAGO等，Mendes等人提出开放数据集成框架（linked data integration framework，LDIF）用于对LOD只是库产品进行融合，共有四个步骤：1，获取知识。2，概念匹配。3，实体匹配。4，知识评估。确保只是图谱的一致性和准确性。</p><h4 id="2-合并关系知识库"><a href="#2-合并关系知识库" class="headerlink" title="2) 合并关系知识库"></a>2) 合并关系知识库</h4><p>可以利用RDB2RDF的开源工具（Triplif, D2RServer, OpenLink Virtuoso, SparqlMap等）将关系数据库转化为RDF，从而融入到知识图谱中。</p><p>W3C推出了2中映射语言标准：</p><ol><li>Direct Mapping：采用直接映射的方式，将关系数据库表结构和数据直接输出为RDF图，在RDF图中所用到的用于表示类和谓词的术语与关系数据库中的表名和字段名保持一致。</li><li>R2RML：有较高的灵活性和可定制型，允许为给定的数据库结构定制词汇表，可以将关系数据库通过R2RML映射为RDF数据集，其中所用的术语如类的名称，谓词均来自定义词汇表。</li></ol><h2 id="2-3-知识加工"><a href="#2-3-知识加工" class="headerlink" title="2.3 知识加工"></a>2.3 知识加工</h2><p>通过信息抽取，可以从原始语料中提取出实体、关系和属性等知识要素。<br>在经过知识融合，可以消除实体指称项与实体对象之间的歧义，得到实施表达。<br>但事实本身并不等于知识，需要进行知识加工。</p><h3 id="2-3-1-本体构建"><a href="#2-3-1-本体构建" class="headerlink" title="2.3.1 本体构建"></a>2.3.1 本体构建</h3><p>本体是对概念进行建模的规范，是描述客观世界的抽象模型，以形式化方式对概念及其之间的联系给给出明确定义。</p><ul><li>人工编辑的方式手工构建（借助本体编辑软件）。</li><li>数据驱动的方式自动构建，然后采用算法评估和人工审核结合的方式加以修正和确认。（主流）<ol><li>实体并列关系相似度计算：考察两个实体在多大程度上属于同一概念分类。<ul><li>模式匹配法：预先定义实体对模式，通过模式匹配取得给定关键字组合共现频率，计算相似度。</li><li>分布相似度法：假设相似的上下文中频繁出现的实体语义相似，将每个实体表示为N维向量，每个维度表示预先定义的上下文环境，向量元素值表示尸体出现在各上下文环境中的概率，然后通过求解向量间的相似度，得到实体的并列关系相似度。</li></ul></li><li>实体上下位关系抽取：用于确定概念之间的隶属（IsA）关系。<ul><li>基于语法模式出去IsA实体对。</li><li>基于语义的迭代技术。利用概率模型判定IsA关系和区分上下位词，通常会借助百科类网站提供的概念分类知识来帮助训练模型。</li></ul></li><li>本体生成：对各层次得到的概念进行聚类，并对其进行语义类的标定。<ul><li>实体聚类方法，难点在于经信息抽取得到的实体描述非常简短，缺乏必要的上下文信息，导致许多统计模型不可用。</li></ul></li></ol></li></ul><h3 id="2-3-2-知识推理"><a href="#2-3-2-知识推理" class="headerlink" title="2.3.2 知识推理"></a>2.3.2 知识推理</h3><ul><li>基于逻辑的推理<ul><li>一阶谓词逻辑，建立在命题（个体&amp;谓词两部分）的基础上。适用于简单关系。</li><li>描述逻辑，基于对象的知识表示的形式化工具，是一阶谓词逻辑的子集。借助TBox（terminology box）和ABox (assertion box)，将基于描述逻辑的推理最终归结为ABox的一致性检验问题，从而简化并最终实现关系推理。</li><li>基于规则的推理。因在描述属性合成和属性值转移方面，网络本体语言的表达能力显得不足，为实现推理，可利用规则语言（如，SWRL）对本体模型添加规则进行功能拓展。</li></ul></li><li>基于图的推理方法<ul><li>神经网络模型</li><li>Path Ranking算法</li></ul></li></ul><p>加入知识库前需要进行可证明性检查、矛盾性检查、冗余性检查以及独立性检查。<br>此外跨知识库的知识推理也是大趋势，如卢道设等的工作。</p><h3 id="2-3-3-质量评估"><a href="#2-3-3-质量评估" class="headerlink" title="2.3.3 质量评估"></a>2.3.3 质量评估</h3><p>原因：</p><ol><li>受现有技术技术水平的限制，采用开放域信息抽取技术得到的知识元素可能存在错误，知识推理得到的知识也没有保障。</li><li>随着开放关联数据项目的推进，子项目产生的知识库产品间的质量差异也在增大，数据间的冲突日益增多，如何对其质量进行评估，对全局知识图谱构建起着重要作用。</li></ol><p>意义：对知识的可信度进行量化，通过舍弃置信度较低的知识，保障知识库的质量。<br>举例：Mendes对LDIF提出的Sieve方法，Fader对REVERB系统提出的逻辑斯蒂回归模型，谷歌等的例子。</p><h2 id="2-4-知识更新"><a href="#2-4-知识更新" class="headerlink" title="2.4 知识更新"></a>2.4 知识更新</h2><p>两方面：</p><ul><li>概念层的更新：添加新概念。人工审核。</li><li>数据层的更新：新增或更新实体、关系和属性值。考虑数据源的可靠性、数据的一致性。选择百科类网站等可靠的数据源，并选择个数据源中出现频率高的事实和属性加入知识库，也可以采用众包的模式。</li></ul><p>两种方式：</p><ul><li>数据驱动下的全面更新。方式简单，但资源消耗大，需大量人力进行系统维护。</li><li>增量更新，资源消耗小，但需要大量人工干预，实施起来困难。</li></ul><h1 id="3-跨语言知识图谱的构建"><a href="#3-跨语言知识图谱的构建" class="headerlink" title="3 跨语言知识图谱的构建"></a>3 跨语言知识图谱的构建</h1><p>意义：</p><ol><li>弥补单语种知识库的不足。</li><li>利用多语种在知识表达上的互补性，增加知识的覆盖率和共享度。</li><li>可比较不同语言对统一制式的表述，来过滤错误信息，更新过时信息。</li></ol><p>关键问题有三个，跨语言本体的构建，见2.3.1节。其他两个如下。</p><h2 id="3-1-跨语言知识抽取"><a href="#3-1-跨语言知识抽取" class="headerlink" title="3.1 跨语言知识抽取"></a>3.1 跨语言知识抽取</h2><p>欧盟的Xlike和我国的Xlore项目。<br>思路是借助于丰富的源语种知识自动化抽取缺失的目标语种知识。</p><h2 id="3-2-跨语言知识链接"><a href="#3-2-跨语言知识链接" class="headerlink" title="3.2 跨语言知识链接"></a>3.2 跨语言知识链接</h2><ul><li>模式层的链接：核心是本体映射，如果两个本体间存在语义上的概念关联，则通过语义关联实现二者之间的映射，本体映射的目的是实现知识的共享和重用。</li><li>数据层的链接。</li></ul><p>距离Wang等的基于链接因子图模型的跨语言知识链接方法，基于链接相似度方法。</p><h1 id="4-知识图谱的应用"><a href="#4-知识图谱的应用" class="headerlink" title="4 知识图谱的应用"></a>4 知识图谱的应用</h1><p>智能语义搜索、移动个人助理以及深度问答系统。<br>基于知识图谱的问答系统可分为2类：</p><ul><li>基于信息检索的问答系统。把问题转变为基于知识库的结构化查询。</li><li>基于语义分析的问答系统。首先通过语义分析正确理解问题的含义，然后将问题转变为知识库的精确查询。</li></ul><h1 id="5-问题与挑战"><a href="#5-问题与挑战" class="headerlink" title="5 问题与挑战"></a>5 问题与挑战</h1><ol><li>信息抽取环节，面向开放域的信息抽取方法研究还处于起步阶段，部分研究成果虽在特定数据集上缺德较好结果，但限制多，扩展性不好。</li><li>知识融合环节。如何实现准确的实体链接是一个主要挑战。</li><li>知识加工是最具特色的知识图谱技术，同时也是该领域最大的挑战之所在。主要研究问题：本体的自动构建、知识推理技术、知识质量评估手段以及推理技术的应用。</li><li>知识更新环节，如何确保自动化更新的有效性是一个重大挑战。</li><li>如何解决知识的表达、存储与查询问题。</li></ol><h1 id="6-结束语"><a href="#6-结束语" class="headerlink" title="6 结束语"></a>6 结束语</h1><p>互联网正从包含网页和网页之间超链接的文档万维网转变为包含大量描述各种实体和实体之间丰富关系的数据万维网。知识图谱作为下一代智能搜索的核心关键技术，具有重要的理论研究价值和现实的应用价值。本文从知识图谱构建的视角，对知识图谱的内涵，以及知识图谱构建关键技术的研究发展现状进行了全面调研和深入分析，并对知识图谱构建工作面临的重要挑战和关键问题进行了总结。<br>知识图谱的重要性不仅在于他是一个全局知识库，是支撑智能搜索和深度问答等智能应用的基础，而且在于他是一把钥匙，能够打开人类的知识宝库，为许多相关学科领域开启新的发展机会。从这个意义上来看，知识图谱不仅是一项技术，更是一项战略资产。本文的主要目的是介绍和宣传这项技术，希望吸引更多人重视和投入这项研究工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;因实验室的项目需要，对跨界服务知识图谱构建技术，进行相关的调研。&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;对知识图谱的定义和内涵进行说明
      
    
    </summary>
    
      <category term="知识图谱" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
    
      <category term="知识图谱" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
      <category term="语义网" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/%E8%AF%AD%E4%B9%89%E7%BD%91/"/>
    
      <category term="自然语言处理" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
      <category term="语义搜索引擎" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/%E8%AF%AD%E4%B9%89%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>《TrieJoin: Efficient Triebased String Similarity Joins with EditDistance Constraints》——读书笔记</title>
    <link href="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/10/18/%E3%80%8ATrieJoin-Efficient-Triebased-String-Similarity-Joins-with-EditDistance-Constraints%E3%80%8B%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/LiuKaixin/LiuKaixin.github.io/2017/10/18/《TrieJoin-Efficient-Triebased-String-Similarity-Joins-with-EditDistance-Constraints》——读书笔记/</id>
    <published>2017-10-18T10:48:52.000Z</published>
    <updated>2017-10-19T03:37:34.516Z</updated>
    
    <content type="html"><![CDATA[<p><em>虽然师兄说，看PPT就行了，但是我粗略一看PPT感觉说的貌似太简略了，还是得看一下论文。。。应该是水平太低所以看PPT没有深入理解吧，希望这次看论文能快点！（有选择的看）</em></p><h1 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h1><p>主要工作：使用编辑距离研究字符串相似。<br>现有方法使用filter-and-refine框架，缺点如下：</p><ol><li>对长度小于30的短字符串效果不好。</li><li>巨大的索引。</li><li>数据集更新的成本很大。</li></ol><p>本文使用trie-join框架，能用小的索引生成结果。使用trie结构索引字符串，并使用trie剪枝找到相似子串。并且支持数据集的动态更新。</p><h1 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1.INTRODUCTION"></a>1.INTRODUCTION</h1><p>similarity join简介。<br>相似函数：jaccard similarity，cosine similarity，<strong>edit distance</strong>。<br>举例之前工作，并指明缺点（见摘要）。<br>本方法解决了之前的所有问题。<br>贡献：</p><ol><li>We propose a trie-based framework for efficient string similarity joins with edit-distance constraints.</li><li>We devise efficient trie-join-based algorithms and develop pruning techniques to achieve high performance.</li><li>We extend our method to support dynamic update of data sets efficiently.</li></ol><h1 id="2-TRIE-BASED-FRAMEWORK"><a href="#2-TRIE-BASED-FRAMEWORK" class="headerlink" title="2.TRIE-BASED FRAMEWORK"></a>2.TRIE-BASED FRAMEWORK</h1><h2 id="2-1-Problem-Formulation"><a href="#2-1-Problem-Formulation" class="headerlink" title="2.1 Problem Formulation"></a>2.1 Problem Formulation</h2><p>如果两个字符串编辑距离小于阈值，则两个字符串相似。</p><blockquote><p><strong>Definition 1 (String Similarity Joins).</strong> Given two sets of strings R and S, and an edit-distance threshold $\tau$, a similarity join finds all similar string pairs $<r,s>\in R\times S$ such that $ED(r,s)\le \tau$</r,s></p></blockquote><h2 id="2-2-Prefix-Pruning"><a href="#2-2-Prefix-Pruning" class="headerlink" title="2.2 Prefix Pruning"></a>2.2 Prefix Pruning</h2><p>naive solution：计算所有字符串对的编辑距离。<br>使用动态规划提早终止编辑距离的计算。<br>string $r=r_1,r_2…r_n$, $s=s_1,s_2…s_m$,<br>matrix D(i,j): the edit distance between the prefix $r_1,r_2…r_i$ and $s_1,s_2…s_j$<br>D(0,j)=j for $0\le j\le n$, and<br>D(i,j)=min(D(i-1,j)+1,D(i,j-1)+1,D(i-1,j-1)+$\theta$) where $\theta=0$ if $r_i=s_j$; otherwise $\theta=1$<br>D(i,j) is an active entry if $D(i,j)\le \tau$<br><img src="http://ouqbyuben.bkt.clouddn.com/images/TrieJoin%20Efficient%20Triebased%20String%20Similarity%20Joins%20with%20EditDistance%20Constraints/fig1.png"><br>如图没有active entries时，结束搜索。</p><h2 id="2-3-Our-Observation"><a href="#2-3-Our-Observation" class="headerlink" title="2.3 Our Observation"></a>2.3 Our Observation</h2><h3 id="Observation-1-Subtrie-Pruning"><a href="#Observation-1-Subtrie-Pruning" class="headerlink" title="Observation 1 - Subtrie Pruning:"></a>Observation 1 - Subtrie Pruning:</h3><p>通过前缀可以剪枝掉很多字符串。</p><blockquote><p><strong>Lemma 1 (Subtrie Pruning).</strong> Given a trie T and a string s, if node n is not an active node for every prefix of s, then n’s descendants will not be similar to s.</p></blockquote><p>Trie-Search: 首先为R内的所有字符串构建trie树，然后基于subtrie pruning对S中的每个字符串计算active-node set $A_s$。</p><h3 id="Observation-2-Dual-Subtrie-Pruning"><a href="#Observation-2-Dual-Subtrie-Pruning" class="headerlink" title="Observation 2 - Dual Subtrie Pruning:"></a>Observation 2 - Dual Subtrie Pruning:</h3><p>Subtrie Pruning只利用了R中的trie结构。<br>对R和S中的字符串构建了一个大的Trie，同时对R和S进行subtrie pruning。</p><blockquote><p><strong>Lemma 2 (Dual Subtrie Pruning).</strong> Given two trie nodes u and v, if u is not an active node for every ancestor of v, and v is not an avtive node for every ancestor of u, the strings under u and v connot be similar to each other.</p></blockquote><p>但利用dual trie pruning，不能直接在树中搜索找到相似对。</p><h1 id="3-TRIE-BASED-ALGORITHMS"><a href="#3-TRIE-BASED-ALGORITHMS" class="headerlink" title="3. TRIE-BASED ALGORITHMS"></a>3. TRIE-BASED ALGORITHMS</h1><p>为便于表示，关注自连接，即R=S。</p><h2 id="3-1-Trie-Traverse-Algorithm"><a href="#3-1-Trie-Traverse-Algorithm" class="headerlink" title="3.1 Trie-Traverse Algorithm"></a>3.1 Trie-Traverse Algorithm</h2><p><strong>Algorithm Description：</strong><br>首先为S中的字符串构建trie索引，然后先序遍历，对于每个节点，计算其active-node set，到达叶子结点，则和active-node set中的叶子结点构成相似对。<br><strong>Computing Active-Node Sets: </strong>利用其父节点的active-node set $A_p$，计算本节点active-node set $A_n$，$A_n$中的每个点都能在$A_p$中找到父节点。</p><blockquote><p><strong>Lemma 3.</strong> Given a node n, let p denote n’s parent, for each node $n^{‘}\in A_n$, there must exist a node $p^{‘}\in A_p$, such that $p^{‘}$ is an ancestor of $n^{‘}$.</p></blockquote><p>因为从$A_p$计算$A_n$的复杂度为$O(\tau \cdot |A_n|)$，所以Trie-Traverse的时间复杂度为$O(\tau \cdot |A_T|)$<br><img src="http://ouqbyuben.bkt.clouddn.com/images/TrieJoin%20Efficient%20Triebased%20String%20Similarity%20Joins%20with%20EditDistance%20Constraints/fig4.png"></p><h2 id="3-2-Trie-Dynamic-Algorithm"><a href="#3-2-Trie-Dynamic-Algorithm" class="headerlink" title="3.2 Trie-Dynamic Algorithm"></a>3.2 Trie-Dynamic Algorithm</h2><p>利用active nodes的对称性：if u is an active node of v, then v must be an active node of u。减少冗余的计算。<br>Trie-Dynamic: 动态的构建trie结构，每次插入新的节点，计算在当前trie结构上新节点的active-node set，并基于对称性更新其他节点的active-node set。<br>时间复杂度下降为1/2，但需要维护所有点的active-node set 使得空间复杂度升高。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/TrieJoin%20Efficient%20Triebased%20String%20Similarity%20Joins%20with%20EditDistance%20Constraints/fig5.png"></p><h2 id="3-3-Trie-PathStack-Algorithm"><a href="#3-3-Trie-PathStack-Algorithm" class="headerlink" title="3.3 Trie-PathStack Algorithm"></a>3.3 Trie-PathStack Algorithm</h2><p>Trie-Traverse：内存占用更小但有一些冗余的active-node计算。<br>Trie-Dynamic：避免了重复计算但使用了更多的内存。<br>Trie-PathStack解决了上述问题。<br>首先，维护一个”virtual partial” subtrie保存所有访问过的节点。对于每个未访问的节点，首先设置为已访问，然后计算”virtual partial” subtrie中的active-node set。<br>然后，先序遍历trie节点，并用栈保存需要被更新的节点。在先序遍历时，用栈保存从根到当前节点路径上的所有节点，访问当前节点时，其父节点一定在栈顶，利用父节点active-node set计算当前节点的active-node set，计算后只需更新栈中最多$\tau$个节点。<br><em>主要是对Trie-Tranverse的改进，不是对整个图进行遍历，而是对已访问的部分进行遍历，然后利用栈保存路径。（这里不太懂，为啥要保存路径呢。。。）</em><br><img src="http://ouqbyuben.bkt.clouddn.com/images/TrieJoin%20Efficient%20Triebased%20String%20Similarity%20Joins%20with%20EditDistance%20Constraints/fig6.png"></p><h1 id="4-PRUNING-TECHNIQUES"><a href="#4-PRUNING-TECHNIQUES" class="headerlink" title="4. PRUNING TECHNIQUES"></a>4. PRUNING TECHNIQUES</h1><p><strong>Length Pruning:</strong> 长度相差大于$\tau$直接剪枝。<br><strong>Single-branch Pruning: </strong>在同一个分支上，如果其叶子节点相同，则父节点可被剪枝。<br><strong>Count Pruning: </strong>如果两个点只能生成一个字符串，则可以删掉一个字符串。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/TrieJoin%20Efficient%20Triebased%20String%20Similarity%20Joins%20with%20EditDistance%20Constraints/fig7.png"></p><h1 id="5-INCREMENTAL-SIMILARITY-JOINS"><a href="#5-INCREMENTAL-SIMILARITY-JOINS" class="headerlink" title="5. INCREMENTAL SIMILARITY JOINS"></a>5. INCREMENTAL SIMILARITY JOINS</h1><blockquote><p><strong>Definition 2 (Incremental Similarity Joins).</strong> Given a set of strings S, a new string set $\Delta S$, and an edit-distance threshold $\tau$, an incremental similarity join finds all similar string pairs $(r\in \Delta S, s\in S\cup \Delta S)$ such that $ED(r,s)\le \tau.$</p></blockquote><img src="http://ouqbyuben.bkt.clouddn.com/images/TrieJoin%20Efficient%20Triebased%20String%20Similarity%20Joins%20with%20EditDistance%20Constraints/fig8.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;虽然师兄说，看PPT就行了，但是我粗略一看PPT感觉说的貌似太简略了，还是得看一下论文。。。应该是水平太低所以看PPT没有深入理解吧，希望这次看论文能快点！（有选择的看）&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;ABSTRACT&quot;&gt;&lt;a href=&quot;#ABSTRACT&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《Top-k Exploration of Query Candidates for Efficient Keyword Search on GraphShaped RDF Data》——读书笔记</title>
    <link href="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/09/29/%E3%80%8ATop-k-Exploration-of-Query-Candidates-for-Efficient-Keyword-Search-on-Graph-Shaped-RDF-Data%E3%80%8B%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/LiuKaixin/LiuKaixin.github.io/2017/09/29/《Top-k-Exploration-of-Query-Candidates-for-Efficient-Keyword-Search-on-Graph-Shaped-RDF-Data》——读书笔记/</id>
    <published>2017-09-29T07:53:31.000Z</published>
    <updated>2017-10-06T11:45:33.808Z</updated>
    
    <content type="html"><![CDATA[<p><em>首先，初步确定一下本周的规划，今明两天读本篇论文，以及回顾之前的论文（按照师兄说的方式进行泛读），然后周三周四学习斯坦福的课程。周五将没有整理的论文整理完全，周六日搞定本篇和上篇论文。</em></p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>从关键词中计算出queries之后，让用户选择合适的，然后送入数据库引擎进行查询。另外对于queries的计算，提出了找top-k子图的新型算法。</p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>提出关键词这样的搜索一直以来都是研究的重点。<br>Labelled query model：不需要用户对结构有任何的了解，只是单纯的将关键词和“labels”联系起来。<br>现在关键词搜索的主要思路：将关键词映射到data elements（很多使用精确匹配），搜索连接关键词的elements的子图（如Blinks中的distinct root assumption），基于得分函数（被提出了很多，从路径长度到IR中的复杂度量）输出top-k个子图（需要计算每个选项的上限和下限）。任务可分为四个：</p><ol><li>keyword mapping.</li><li>graph exploration.</li><li>scoring.</li><li>top-k computation.</li></ol><p>本方法结合了语法和语义相似度，因此IR概念支持模糊匹配。本文贡献如下：</p><ul><li><strong>Keyword Search through Query Computation </strong> 将关键词转化为结构化查询的元素（而不是答案的一部分），让用户选top-k个查询中的一个（而不是直接把top-k个答案给出）。</li><li><strong>Algorithms for Subgraph Exploration</strong> 当前的方法通常将关键词映射到节点，算法计算出树形的答案。但关键词也可能映射到边，所以答案结构也不一定是树。</li><li><strong>Efficient and Complete Top-k through Graph Summarization</strong> 很难簿记计算top-k所需的信息，现在的方法不能确保结果是真正的top-k。因此我们引入了复杂的数据结构保存所有候选的得分。为了效率，利用摘要图进行剪枝。</li></ul><h1 id="2-Problem-Definition"><a href="#2-Problem-Definition" class="headerlink" title="2. Problem Definition"></a>2. Problem Definition</h1><p><strong>Data</strong><br><img src="http://ouqbyuben.bkt.clouddn.com/images/Top-k%20Exploration%20of%20Query%20Candidates%20for%20Efficient%20Keyword%20Search%20on%20Graph-Shaped%20%28RDF%29%20Data/Definition1.png"><br><strong>Queries</strong><br>用户的查询$Q_U$就是关键词集合，系统的查询$Q_S$是conjunctive queries.<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Top-k%20Exploration%20of%20Query%20Candidates%20for%20Efficient%20Keyword%20Search%20on%20Graph-Shaped%20%28RDF%29%20Data/Definition2.png"><br><strong>Answers</strong><br>就是把查询中的distinguished variables 替换成子图中的节点。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Top-k%20Exploration%20of%20Query%20Candidates%20for%20Efficient%20Keyword%20Search%20on%20Graph-Shaped%20%28RDF%29%20Data/Definition3.png"><br><strong>Problem</strong><br>主要考虑conjunctive queries的计算。</p><h1 id="3-Overview-of-the-Approach"><a href="#3-Overview-of-the-Approach" class="headerlink" title="3. Overview of the Approach"></a>3. Overview of the Approach</h1><p>首先举例几个关键词，指出他们之间的连接需要推断关键词之间的连接。以往的工作使用图的schema来推断。本文的方法如下：<br><strong>Query Computation</strong> </p><ol><li>keyword通过映射得到keyword elements。</li><li>通过图的搜索将keyword elements连接起来找到connecting element。</li><li>connecting element与keyword elements之间的路径构成了matching subgraph。</li><li>对于每个子图，通过graph elements到query elements的映射得到conjunctive query。<br><strong>Preprocessing</strong><br>预处理得到keyword index，用于keyword-to-element映射。<br>为了图搜索，建立graph index——原始图的摘要。<br>the augmented index 可以推导query中谓词、常量和结构。<br><strong>Running Example</strong></li></ol><img src="http://ouqbyuben.bkt.clouddn.com/images/Top-k%20Exploration%20of%20Query%20Candidates%20for%20Efficient%20Keyword%20Search%20on%20Graph-Shaped%20%28RDF%29%20Data/fig1.png"><img src="http://ouqbyuben.bkt.clouddn.com/images/Top-k%20Exploration%20of%20Query%20Candidates%20for%20Efficient%20Keyword%20Search%20on%20Graph-Shaped%20%28RDF%29%20Data/fig2.png"><img src="http://ouqbyuben.bkt.clouddn.com/images/Top-k%20Exploration%20of%20Query%20Candidates%20for%20Efficient%20Keyword%20Search%20on%20Graph-Shaped%20%28RDF%29%20Data/fig3.png"><h1 id="4-Indexing-Graph-Data"><a href="#4-Indexing-Graph-Data" class="headerlink" title="4. Indexing Graph Data"></a>4. Indexing Graph Data</h1><h2 id="A-The-Keyword-Index"><a href="#A-The-Keyword-Index" class="headerlink" title="A. The Keyword Index"></a>A. The Keyword Index</h2><p>关键词可能指C-vertices，E-vertices，V-vertices或 edges，但在构建索引时忽略E-vertices因为用户不太可能直接输入E-vertex的URI。<br>keyword index 就是一个keyword-element映射，但是对于V-vertex和A-edge所存储的结构比较特殊。<br>为了识别不予数据元素的标签严格匹配的关键词，keyword-element 实现为一个倒排列表。首先对labels进行分析得到其terms，然后利用WordNet得到terms的同义词，上位词和下位词。所以语义相似的graph element会被检出，并用Levenshtein距离度量keywords到terms的语法相似性。</p><h2 id="B-The-Graph-Schema-Index"><a href="#B-The-Graph-Schema-Index" class="headerlink" title="B. The Graph Schema Index"></a>B. The Graph Schema Index</h2><p>用作搜索连接keyword elements的子结构。<br>之前的文章在全图进行搜索，本文旨在从边推出查询结构，从点推出常量（变量）。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Top-k%20Exploration%20of%20Query%20Candidates%20for%20Efficient%20Keyword%20Search%20on%20Graph-Shaped%20%28RDF%29%20Data/Definition4.png"><br>A-edges和V-vertices并不会有助于连接keyword elements，除非他们就是keyword elements。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Top-k%20Exploration%20of%20Query%20Candidates%20for%20Efficient%20Keyword%20Search%20on%20Graph-Shaped%20%28RDF%29%20Data/Definition5.png"></p><p>构建$G^{‘}_K$需要利用来自映射的数据结构，即[V-vertex, A-edge, $(C-vertex_1,…,C-vertex_n)$]和(A-edge, C-vertex)。为了关键词能够匹配V-vertex，将A-edge$(C-vertex_i,V-vertex)$加入$G^{‘}$;为了关键词能够匹配A-edge，将A-edge$(C-vertex_i,Value)$加入$G^{‘}$.</p><h1 id="5-Scoring"><a href="#5-Scoring" class="headerlink" title="5. Scoring"></a>5. Scoring</h1><p>介绍了一些得分函数，如PageRank（为节点打分），最短路径（为路径打分），TF/IDF（为keyword element打分）。<br>对于图来说，其由路径构成，其成本函数如下：</p><script type="math/tex; mode=display">C_G=\sum_{p_i\in P}C_{p_i}</script><p>而路径由其elements组成：</p><script type="math/tex; mode=display">C_{p_i}=\sum_{n\in p_i}c(n)</script><p><strong>Path Length</strong> 假设用户所需的实体紧密相连。其得分函数为<script type="math/tex">C_1=\sum_{p_i\in P}\sum_{n\in p_i}1</script><br><strong>Popularity Score</strong> 计算摘要图中element的popularity，越流行则在路径中贡献越小。</p><p><script type="math/tex">C_2=\sum_{p_i\in P}\sum_{n\in p_i}c(n)</script>，其中对于点v，<script type="math/tex">c(v)=1-\frac{|v_{agg}|}{|V|}</script>，对于边e，<script type="math/tex">c(e)=1-\frac{|e_{agg}|}{|E|}</script>。<br>|V|：摘要图中点的总数。</p><p><script type="math/tex">v_{agg}</script>：graph index 中聚集在一个C-vertex的E-vertex的数量。<br>|E|：摘要图中边的总数。</p><p><script type="math/tex">e_{agg}</script>：摘要途中聚集在一个R-edge的R-edge的数量。<br><strong>Keyword Matching Score</strong> </p><p><script type="math/tex">C_2=\sum_{p_i\in P}\sum_{n\in p_i}\frac{c(n)}{S_m(n)}</script> $S_m(n)$代表element n的得分，对于Keyword element，范围是[0,1]，其他元素则一律设置为1。其从语法语义两方面考虑，得分越高则路径的成本越小。</p><p>前两个可以离线计算，因为element在不同路径的话，会计算多次，所以其更倾向于Keyword elements紧密连接的子图。</p><h1 id="6-Computation-of-Queries"><a href="#6-Computation-of-Queries" class="headerlink" title="6. Computation of Queries"></a>6. Computation of Queries</h1><p>对于查询计算，有五个任务：</p><ol><li>mapping of keywords to data elements.</li><li>augmentation of the summary graph.</li><li>exploration of the graph to find subgraphs connecting the keyword elements.</li><li>top-k processing.</li><li>generation of the query for the top-k subgraphs<br>前两个已经解决，本节解决3-5.</li></ol><h2 id="A-Algorithms-for-Graph-Exploration"><a href="#A-Algorithms-for-Graph-Exploration" class="headerlink" title="A. Algorithms for Graph Exploration"></a>A. Algorithms for Graph Exploration</h2><p>首先定义最小匹配子图：<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Top-k%20Exploration%20of%20Query%20Candidates%20for%20Efficient%20Keyword%20Search%20on%20Graph-Shaped%20%28RDF%29%20Data/Definition6.png"><br>一个条件定义包含所有关键词，另一个确保联通。<br>与现有的搜索算法进行对比。<br><strong>Backward Search</strong> 从Keyword elements出发迭代地沿入边访问elements直到找到一个connecting element，即answer root。<br><strong>Bidirectional Search</strong> 该方法认为从一些顶点可以通过跟随传出而不是传入边缘来更快地达到答案根。故使用启发式激活因子来估计边缘将到达answer root的可能性。这些因子是从一般图形拓扑和已经探索的元素得出的。虽然其在很多情况下表现很好，但最差性能无法保证。<br><strong>Searching with Distance Information</strong> 通过存储在索引中的附加连接信息保证最差性能是m-optimal。在每次迭代中，通过该信息可确定能够达到keyword element的elements以及最短的距离，从而有目标的进行搜索。不过构建这些信息十分费力。</p><p>因为关键词也有可能对应边，所以查询出的结果不再是树，而是图。成本来自于两方面：query-independent，query-specific。索引技术只能解决query-independent的成本。</p><h2 id="B-Search-for-Minimal-Matching-Subgraph"><a href="#B-Search-for-Minimal-Matching-Subgraph" class="headerlink" title="B. Search for Minimal Matching Subgraph"></a>B. Search for Minimal Matching Subgraph</h2><img src="http://ouqbyuben.bkt.clouddn.com/images/Top-k%20Exploration%20of%20Query%20Candidates%20for%20Efficient%20Keyword%20Search%20on%20Graph-Shaped%20%28RDF%29%20Data/alg1.png"><p><strong>Input and Data Structures</strong> </p><p><script type="math/tex">G^{'}_K</script>：摘要图    </p><p><script type="math/tex">K=(K_1,...,K_m)</script>：keyword elements<br>k：查询数量<br>c(n,k,p,d,w): n 刚访问的graph element，k  c所在路径起点的keyword element，<br>p 父游标，d 距离，w 成本。<br>$LG^{‘}$: 保存候选子图的全局变量。<br>$K_{lowC}$： 存储成本最低的keyword element。<br><strong> Initialization and General Idea</strong> 从一系列keyword elements出发，为每个查询创建游标，游标的拓展就是搜索的拓展。<br><strong>Garph Exploration</strong><br>需要注意邻居可能是出边，入边和点。<br><strong>Computation of Distinct Paths</strong><br>解决环形的问题。<br><strong>Termination</strong> 一项被满足</p><ol><li>已经计算出所有可能的不同路径，使得LQ中没有更多的游标。</li><li>所有keyword elements在给定长度内的所有路径被搜索。</li><li>top-k查询被计算。</li></ol><h2 id="C-Top-k-Computation"><a href="#C-Top-k-Computation" class="headerlink" title="C. Top-k Computation"></a>C. Top-k Computation</h2><img src="http://ouqbyuben.bkt.clouddn.com/images/Top-k%20Exploration%20of%20Query%20Candidates%20for%20Efficient%20Keyword%20Search%20on%20Graph-Shaped%20%28RDF%29%20Data/alg2.png"><p>基本思想来自TA（Threshold Algorithm）算法。候选子图的最高成本——下限的计算，其余子图的最低成本——上限的计算如下：<br><strong>Candidate Subgraphs</strong> element n如果能达到所有关键词（其每个关键词游标都不空），则可能对应多个子图（每个游标可能有多个路径），计算每个子图的成本并排序。<br><strong>Remaining Subgraphs</strong> </p><p>和其他方法相比，我们首先支持图，不限于树。不止是距离信息，还设置了多样的成本函数。首先对这些信息（那些信息）进行索引可以提高Top-k处理和图搜索的效率。<br>In our approach, minimality can be guaranteed for any score metrics, given that the scoring function is monotonic.<br>和【1】对比。<br>时间复杂度$|G|^{d_max}$<br>空间复杂度$k\cdot |K|\cdot |G|$</p><h2 id="D-Query-Mapping"><a href="#D-Query-Mapping" class="headerlink" title="D. Query Mapping"></a>D. Query Mapping</h2><p>将子图映射到conjunctive query。<br><strong>Processing of Vertices</strong> constant(v) 返回点v的label，var(v)返回v代表的变量。<br><strong>Mapping of A-edges</strong><br><strong>Mapping of R-edges</strong><br>认为相同根的不同答案树是有价值的。<br>将所有答案呈现给用户， 让用户选择。</p><h1 id="7-Evaluation"><a href="#7-Evaluation" class="headerlink" title="7. Evaluation"></a>7. Evaluation</h1><p>基于关键词查询，计算出top-k个conjunctive queries，转化成自然语言问题，并展现给用户。<br>数据集：DBLP、TAP、LUBM。</p><h2 id="A-Effectiveness-Study"><a href="#A-Effectiveness-Study" class="headerlink" title="A. Effectiveness Study"></a>A. Effectiveness Study</h2><p>12人DBLP—30查询 TAP—9查询<br>使用Reciprocal Rank（RR） =1/r。r是正确查询的排名。</p><h2 id="B-Performance-Evaluation"><a href="#B-Performance-Evaluation" class="headerlink" title="B. Performance Evaluation"></a>B. Performance Evaluation</h2><p>对比算法：bidirectional search，1000 BFS，1000 METIS， 300 BFS，300METIS。<br><strong>Comparative Analysis</strong> query computation的时间，query processing的时间。实验中总时间=计算top-10的时间+处理查询直到找到至少10个答案的时间。<br><strong>Search Performance</strong> k 的影响——线性。查询长度<br><strong>Index Performance</strong> 索引大小及建索引的时间，都可以接受。</p><h1 id="8-Related-Work"><a href="#8-Related-Work" class="headerlink" title="8. Related Work"></a>8. Related Work</h1><p>native approaches：直接在图结构数据上进行关键词搜索，虽然schema-agnostic，但是需要特定的目录和存储机制。<br>Database extensions：可以利用底层数据库的机制，如DBXplorer，Discover。用schema中的信息连接构建的表达式，从而将关键词转成候选网络，再将候选网络转成SQL查询。<br>本方法结合两种方法的优点，一、schema agnostic，构建了schema，并在schema上进行搜索。二、可以利用底层RDF存储的机制。<br>之前工作：计算得出答案，将关键词映射到三元组。<br>本方法：计算得出top-k查询，将关键词映射到查询的element（这样可以支持更多pattern）。<br>前向和后向搜索会利用索引存储关键词信息和路径信息，本方法虽然也用关键词和距离索引，但只是为了计算分数。之前方法计算distinct trees，本方法计算一般子图，因此需要遍历所有的入边和出边。<br>本方法通过预留的索引信息在guided exploration下可以得到最佳的得分，离线部分用索引计算，在线部分用TA计算。但其他方法并不能为结果提供top-k保证。</p><h1 id="9-Conclusion-and-Future-Work"><a href="#9-Conclusion-and-Future-Work" class="headerlink" title="9. Conclusion and Future Work"></a>9. Conclusion and Future Work</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;首先，初步确定一下本周的规划，今明两天读本篇论文，以及回顾之前的论文（按照师兄说的方式进行泛读），然后周三周四学习斯坦福的课程。周五将没有整理的论文整理完全，周六日搞定本篇和上篇论文。&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abs
      
    
    </summary>
    
      <category term="论文笔记" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="RDF" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/RDF/"/>
    
      <category term="Keyword" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/Keyword/"/>
    
      <category term="2017年9月" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/2017%E5%B9%B49%E6%9C%88/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客编写</title>
    <link href="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/09/27/hexo%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>https://github.com/LiuKaixin/LiuKaixin.github.io/2017/09/27/hexo编写博客/</id>
    <published>2017-09-27T09:24:00.000Z</published>
    <updated>2017-10-08T07:41:45.994Z</updated>
    
    <content type="html"><![CDATA[<p>需参考网站：<a href="https://github.com/zhaoqingqing/zhaoqingqing.github.io">https://github.com/zhaoqingqing/zhaoqingqing.github.io</a></p><p>昨儿晚上和今天下午都在搞我的博客，本来想搞多终端同步，结果莫名其妙的hexo-admin的deploy功能不能使用了，然后重装了好几次，都没有成功，心里很烦躁。现在冷静下来之后决定用命令去deploy，然后得空去学习js，看看这些东西怎么操作吧。</p><p>博客的编写发布主要参考 <a href="https://righere.github.io/2016/10/10/install-hexo/" target="_blank" rel="external">https://righere.github.io/2016/10/10/install-hexo/</a><br>首先把hexo分支git clone到本地，然后npm install安装hexo。<br>编辑blog还是用hexo-admin<br>然后使用git add .   git commit -m “改了啥”， git push origin hexo将本地仓库同步到远程<br>发布使用命令hexo d -g。</p><p>其他终端先pull，之后进行接下来的操作。心好累，弄了半天还是没有什么结果。先暂且这么用着吧。</p><p>10月8日  数学公式有问题，按照<a href="http://xudongyang.coding.me/math-in-hexo/" target="_blank" rel="external">http://xudongyang.coding.me/math-in-hexo/</a> 修改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;需参考网站：&lt;a href=&quot;https://github.com/zhaoqingqing/zhaoqingqing.github.io&quot;&gt;https://github.com/zhaoqingqing/zhaoqingqing.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="关于博客" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/categories/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2/"/>
    
    
  </entry>
  
  <entry>
    <title>《Answering top-K query combined keywords and structural queries on RDF graphs》——读书笔记</title>
    <link href="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/09/04/%E3%80%8AAnswering-top-K-query-combined-keywords-and-structural-queries-on-RDF-graphs%E3%80%8B%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/LiuKaixin/LiuKaixin.github.io/2017/09/04/《Answering-top-K-query-combined-keywords-and-structural-queries-on-RDF-graphs》——读书笔记/</id>
    <published>2017-09-04T12:36:00.000Z</published>
    <updated>2017-10-12T14:05:35.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h1><p>虽然SPARQL是RDF图上优越的查询语言，但一些查询意图仍无法使用SPARQL句法表达。关键词搜索虽然能够直观表示信息的需求，但表达准确度较低。为了综合两者的优点，提出了混合查询SK query，并使用基于结构化索引的新型查询算法加速查询。为了更进一步提高SK查询的效率还使用了基于距离的优化技术。</p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>目前RDF图十分流行，图1是Yago知识图谱的一个例子。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig1.png"><br>SPARQL基于子图匹配，是查询RDF数据的标准方法。但是由于用户不了解RDF的schema，所以查询的实体和谓词并不能和数据库中対映。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig2-3.png"><br>关键词查询是说明信息需求更直观的方法，但也常得到一些无意义的答案。<br>因此本文结合两者的优点提出SK query，其结果是最接近所有关键词的k个SPARQL结果。我们假设关系的强度依赖于路径长度，另外不同的谓词也应该有不同的权重。<br>该问题的另一个挑战是搜索效率，穷举法的流程如下：    </p><ol><li>用现有技术找出所有匹配的子图。</li><li>计算匹配子图和包含关键词的点间的最短路径。</li><li>找到路径最短的作为答案。</li></ol><p>但该方法太低效，我们为SPARQL查询Q设计了一个下限以尽早结束搜索，另外为结构化剪枝提出一个星型索引。提出一个基于距离的优化加速最短路径距离的计算——选择一些中心点，并使最短路径树以这些点为根；如果搜索到了中心点p，则可以使用根在p的最短路径减少搜索空间。<br>本文贡献：</p><ol><li>提出一个新的查询模式——SK query，结合了SPARQL和关键词，并提供了解决方法。</li><li>提出星型索引并实现最短路径树（基于距离的优化）以减少搜索空间和提高查询性能。</li><li>实验。</li></ol><h1 id="2-Background"><a href="#2-Background" class="headerlink" title="2. Background"></a>2. Background</h1><h2 id="2-1-Preliminaries"><a href="#2-1-Preliminaries" class="headerlink" title="2.1 Preliminaries"></a>2.1 Preliminaries</h2><blockquote><p><strong>Definition 2.1. </strong> An RDF data graph G is denoted as &lt; V(G), E(G), L&gt;, where (1) $V(G)= V_L \cup V_E \cup V_C$ is the set of vertices in RDF graph G ($V_L,\, V_E,\, V_C$ denote literal, entity and class vertices); (2) E(G) is the set of edges in G; and (3) L is a finite set of edge labels, i.e. predicates.<br><strong>Definition 2.2. </strong> An SK query is a pair &lt; Q,q&gt;, where Q is a SPARQL query graph, and q is a set of keywords $\{w_1,w_2,…,w_n\}$.</p></blockquote><p>对于SK query &lt; Q,q&gt;，查询结果是$&lt; M,\{ v_1,v_2,…,v_n\} >$, 其中M是Q的子图匹配，$v_i$是包含关键词$w_i$的literal vertex。</p><blockquote><p><strong>Definition 2.3.</strong> Given a result $r=&lt; M,\{v_1,v_2,…,v_n\}&gt;$, the cost of r is defined as follows:    </p><p><script type="math/tex">Cost(r) =Cost_{content}(r)+Cost_{structure}(r)</script>.<br><strong>Definition 2.4.</strong> Given a result <script type="math/tex">r=< M,\{v_1,v_2,...,v_n\}></script>, the content cost of r is defined as follows:    </p><p><script type="math/tex">Cost_{content}(r)=\sum^{i=n}_{i=1}C(v_i,w_i)</script>,<br>where $C(v_i,w_i)$ is the matching cost between $v_i$ and keyword $w_i$.</p></blockquote><p>结构成本只考虑SPARQL查询中的变量——理由: 用户更感兴趣。（我感觉这并不科研）</p><blockquote><p><strong>Definition 2.5.</strong> Given a result <script type="math/tex">r=< M,\{v_1,v_2,...,v_n\}></script>, the distance between match M and vertex <script type="math/tex">v_i</script> is defined as follows:    </p><script type="math/tex; mode=display">d(M,v_i)=MIN_{v\in M}\{d(v,v_i)\}</script><p>其中v是M中和SPARQL查询中某个变量相关的点$ d( v, v_i ) $是v和G中$v_i $的最短距离。结果r的结构成本：<br>$Cost_{content}(r)=\sum^{i=n}_{i=1} C(v_i,w_i) $</p></blockquote><p>(<strong>Problem Definition</strong>) Given an SK query &lt;Q,q&gt; and parameter k, our problem is to find the k results that have the k-smallest costs.</p><h2 id="2-2-Predicate-salience"><a href="#2-2-Predicate-salience" class="headerlink" title="2.2 Predicate salience"></a>2.2 Predicate salience</h2><p>本文使用最短路径距离评估关系强度。一般的最短路径距离不区分谓词，把”type”、”label”等和普通谓词同等看待不合理。因此引入了predicate salience：    <script type="math/tex">ps(p)=\frac{|V(p)|}{|V(G)|}</script></p><h1 id="3-Overview"><a href="#3-Overview" class="headerlink" title="3. Overview"></a>3. Overview</h1><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig5.png"><p><strong>Keyword Mapping.</strong> 离线时，为每个关键词建立倒排列表。在线时，根据倒排列表获取关键词对应的节点。对于关键词节点，在给定查询上的常用度量是TF/IDF成本。参考文献中有很多成本函数，我们选择其中一种计算包含关键字的节点的成本。<br>本文中主要关心如何找到SPARQL的匹配以及和关键词之间的关系。我们使用现有的IR引擎分析给定的关键词，并执行不精确匹配得到一些语法或语义相似的元素。<br><strong>Candidate Generation. </strong>如果找到能到达所有关键词的节点，则需要使用子图同态检查SPARQL的子图匹配是否包含该点。此步采用“filter-and-refine”策略，首先找到一些没有在任何Q的子图匹配中出现的dummy节点，如果搜索到dummy节点则不执行子图同态。<br>本文提出一种frequent star pattern-based structural index。基于该索引可以为SPARQL查询的变量提供候选列表。<br><strong>Top-k Results Computation. </strong>基于图搜索，循环地计算关键词节点与邻居的距离，找到一个能达到所有关键词的节点，如果不是dummy vertex，则使用SPARQL matching算法。</p><h1 id="4-Candidate-generation-based-on-the-structural-index"><a href="#4-Candidate-generation-based-on-the-structural-index" class="headerlink" title="4. Candidate generation based on the structural index"></a>4. Candidate generation based on the structural index</h1><h2 id="4-1-Structural-index"><a href="#4-1-Structural-index" class="headerlink" title="4.1 Structural index"></a>4.1 Structural index</h2><p>本节提出一个frequent star pattern-based index。从G中挖掘出一些常见的星型模式，并为每个星型模式建立一个节点的倒排列表。选择星型的原因是在SPARQL查询常包含星型子查询。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig6.png"><br>如表2，每个实体的谓词以字典序存储，如图6，sequential pattern和star pattern一一对应，使用现有的sequential pattern挖掘算法，如PrefixSpan来挖掘星型模式。</p><p>我们不能为每个星型模式建立目录，因此我们我们定义了discriminative ratio。L(S)={v|S occurs in v’s adjacent edge seuence}即返回符合星型模式S的所有点v。</p><blockquote><p><strong>Definition 4.1. </strong>Given a star S, its discriminative ratio is defined as follows:<br>$\gamma (S)=\frac{|L(S)|}{|\cap_{S^{‘}\subset S} \,\,L(S^{‘})|}$</p></blockquote><p>如果$\gamma (S)$越大，则说明如果保存S的子集作为目录元素的话，就没必要保存S作为目录元素。因此设定$\gamma (S)\le \gamma_{max}$。但对于只有一条边的星型查询，我们始终将其放入目录中。</p><blockquote><p><strong>Theorem 4.1. </strong> Let F denote all selected index elements (i.e., frequent star patterns). Given a SPARQL query Q, a vertex v in graph G can be pruned (there exists no subgraph match of Q containing v) if the following equation holds.<br>$v\notin \cup_{S\in F \land S \in Q}L(S)$,<br>where $S\in F$ means that S is a selected star pattern and $S\in Q$ is a star pattern included in Q.<br>定义剪枝策略，如果该点不在查询的子结构中，则剪枝。</p></blockquote><h2 id="4-2-Candidate-generation"><a href="#4-2-Candidate-generation" class="headerlink" title="4.2 Candidate generation"></a>4.2 Candidate generation</h2><p>先依据Theorem 4.1剪枝掉不可能的点，然后根据变量的predicate sequence在索引找中找到候选点。</p><blockquote><p><strong>Definition 4.2. Dummy Vertex.</strong> Given a SPARQL query Q, a vertex v in graph G is called a dummy vertex if the following equation holds.<br>$v\notin \cup_{S\in F \land S \in Q}L(S)$,<br>where F denotes all selected frequent star patterns, $S\in F$ means that S is a selected star pattern and $S\in Q$ is a star pattern included in Q.</p></blockquote><p>搜索时，如果v不是dummy vertex，则执行子图同态算法找到包含v的SPARQL查询的匹配结果。</p><h1 id="5-Top-k-results-computation"><a href="#5-Top-k-results-computation" class="headerlink" title="5. Top-k results computation"></a>5. Top-k results computation</h1><h2 id="5-1-Graph-exploration"><a href="#5-1-Graph-exploration" class="headerlink" title="5.1 Graph exploration"></a>5.1 Graph exploration</h2><p>目的是找到图中与关键词节点相联系的节点并计算距离。</p><blockquote><p><strong>Definition 5.1 Distance between a Vertex and Keyword.</strong> Given a vertex v in RDF graph G and a keyword $w_i$, the distance between v and keyword $w_i$ (denoted as $d(v,w_i)$) is the minimum distance between v and a vertexin $V_i$, where $V_i$ includes all literal vertices containing keyword $w_i$ in G.</p></blockquote><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/alg1.png"><p>对每个关键词遍历，然后对于关键词k所在的优先队列使用bfs，搜索邻居，并更新相关变量。</p><blockquote><p><strong>Theorem 5.1.</strong> When a queue head (v,p,|p|) is poped from queue $PQ_i$, the following equation holds.<br>$d(v,w_i)=d[v][i]=|p|$</p><p><strong>Definition 5.2. Seen by a Keyword.</strong> When queue head (v,p,|p|) is popped from queue $PQ_i$, the distance between v and keyword $w_i$ has been computed. We then say that vertex is <em>seen</em> by keyword $w_i$.<br>**Definition 5.3. Fully Seen Vertex, Partially Seen Vertex, and Unseen Vertex.</p></blockquote><h2 id="5-2-Generatinon-of-SPARQl-matches"><a href="#5-2-Generatinon-of-SPARQl-matches" class="headerlink" title="5.2. Generatinon of SPARQl matches"></a>5.2. Generatinon of SPARQl matches</h2><p>找到fully seen vertex v，下一步是计算包含v的SPARQL匹配。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/alg2.png"><br>如算法2所示，我们使用基于DFS的状态转移算法，从fully seen vertex v开始进行匹配处理，对于已经处理过的节点v，因为包含该点的答案都已经得到，所以在处理其他节点时，跳过该点，如图8。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig8.png"></p><blockquote><p><strong>Definition 5.4.</strong> Given a SPARQL query graph Q with m vertices $u_1,…u_m$, a state is a (partial) match of query graph Q.</p></blockquote><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig7.png"><h2 id="5-3-Top-k-computation"><a href="#5-3-Top-k-computation" class="headerlink" title="5.3. Top-k computation"></a>5.3. Top-k computation</h2><p>把所有节点计算后，然后取出top-k的答案，太低效，本节设计了early-stop strategy。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig9.png"></p><blockquote><p><strong>Definition 5.5. Fully Seen Match, Partially Seen Match and Unseen Match.</strong> Given a subgraph match M of SPARQl query Q, if all vertices in M are fully seen vertices, M is called a fully seen match; if M is not a fully seen match and M contains at least one fully seen vertex, it is called a partially seen match. If a match M does not contain any fully seen vertex, it is valled an unseen match.</p></blockquote><p>early-stop strategy：只计算fully seen mateches 的成本，以k-th小的成本作为阈值$\delta$并且计算partially seen matches和unseen matches的下限$\theta_1$和$\theta_2$，当且仅当$\delta &lt;\theta_1 \land\delta &lt;\theta_2$时，提前停止。否则，继续下一轮迭代。</p><h3 id="Fully-Seen-Match"><a href="#Fully-Seen-Match" class="headerlink" title="Fully Seen Match."></a><strong>Fully Seen Match.</strong></h3><p>按照Definition 2.5计算成本，并维护阈值$\delta$。</p><h3 id="Partially-Seen-Match"><a href="#Partially-Seen-Match" class="headerlink" title="Partially Seen Match."></a><strong>Partially Seen Match.</strong></h3><p>按以下方式计算下界。</p><blockquote><p><strong>Theorem 5.2.</strong> Given a partially seen match M of SPARQL query Q, v is a partially seen or an unseen vertex in the match. The following equation holds.<br>$Cost(M)=\sum_{1\le i\le n}d(v,w_i)\ge \sum_{d[v] [w_i]\ne null\land 1\le i\le n}d[v] [w_i] +\sum_{d[v][w_i]= null\land 1\le i\le n}|p_i|$<br>where $[v][w_i]$is the i-th dimension of v’s vector corresponding to keyword $w_i$, and $|p_i|$ corresponds to the current queue head $(v,p_i,|p_i|)$ in queue $PQ_i$</p></blockquote><p>依据Theorem 5.2，a partially seen match M的下界为：</p><blockquote><p><strong>Definition 5.6</strong> Given a match M of SPARQL query Q, the lower bound of a partially seen match M is defined as follows.<br>$lb(M)=MIN_{v\in M} (\sum_{d[v] [w_i]\ne null\land 1\le i\le n}d[v] [w_i] +\sum_{d[v][w_i]= null\land 1\le i\le n}|p_i|)$</p></blockquote><p>所有partially seen matches的下界为：</p><blockquote><p><strong>Definition 5.7</strong> The lower bound $\theta_1$ for all partially seen matches is as follows.<br>$\theta_1=MIN_{M\in PS}(lb(M))$<br>where PS denotes all partially seen matches.</p></blockquote><p>在迭代过程中，一些partially seen matches变成了fully seen matches，阈值$\delta$和$\theta_1$也随之更新。</p><h3 id="Unseen-Match"><a href="#Unseen-Match" class="headerlink" title="Unseen Match."></a>Unseen Match.</h3><p>包含两种点：Partially seen Vertex、 Unseen Vertex.</p><blockquote><p><strong>Theorem 5.3.</strong> For an unseen vertex v, if threshold $\delta\ne \infty$, the following equation holds.<br>$\delta \le \Sigma_{1\le i\le n}d(v,w_i)$</p></blockquote><p>按照Theorem 5.3，unseen match的下限没必要考虑unseen matches。</p><blockquote><p><strong>Definition 5.8. </strong> The lower bound $\theta_2$ for all unseen matches is as follows.<br>$\theta_2=MIN_{v\in PSet}(\sum_{d[v] [w_i]\ne null\land 1\le i\le n}d[v] [w_i] +\sum_{d[v][w_i]= null\land 1\le i\le n}|p_i|),$<br>where PSet contains all partially seen vertices, $d[v][w_i]$ is the i-th dimension of v’s vector corresponding to keyword $w_i$ and $|p_i|$ corresponds to the current queue head $(v, p_i, |p_i|)$ in queue $PQ_i$.</p></blockquote><h3 id="Early-stop-Strategy"><a href="#Early-stop-Strategy" class="headerlink" title="Early-stop Strategy."></a>Early-stop Strategy.</h3><p>在每次迭代中，都检查$\delta\le \theta_1 \land \delta \le \theta_2$.如果条件成立，则算法停止。</p><h1 id="6-Distance-based-optimization"><a href="#6-Distance-based-optimization" class="headerlink" title="6. Distance-based optimization"></a>6. Distance-based optimization</h1><p>算法1使用后向搜索遍历RDF图，为加快搜索，我们提出了pivot-based distance index. 离线时选中一些点作为pivots，预先计算根在pivot的路径，搜索时如果遇到pivot，则利用预存的距离信息，减少搜索空间。</p><h2 id="6-1-Pivot-based-search-for-top-k-results-of-SK-queries"><a href="#6-1-Pivot-based-search-for-top-k-results-of-SK-queries" class="headerlink" title="6.1 Pivot-based search for top-k results of SK queries"></a>6.1 Pivot-based search for top-k results of SK queries</h2><blockquote><p><strong>Definition 6.1.</strong> Given a shortest path tree T rooted at vertex r (denoted as T(r)), pivot p, and vertex v, if the shortest path between r and v crosses pivot p, we say that v is covered by p in T.<br><strong>Theorem 6.1.</strong> if v is covered by p in the shortest path tree T(r), d(r,v)=d(r,p)+d(p,v) where d(r,v) denotes the shortest path distance between r and v.</p></blockquote><p>如图10，T(015)中的点001被pivotcover，d(015,001)=d(015,017)+d(017,001)=2.222.<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig10.png"></p><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/alg3.png"><p>7-17行和18-20行与算法1的对比。</p><h2 id="6-2-Pivot-selection"><a href="#6-2-Pivot-selection" class="headerlink" title="6.2 Pivot selection"></a>6.2 Pivot selection</h2><blockquote><p><strong>Definition 6.2.</strong> Given a shortest path tree T(v) rooted at v and a set of pivots PV, the covered ratio is </p><script type="math/tex; mode=display">cr(T(v))=\frac{|\{v^{'}|v^{'}\,\, is\,\,covered\,\, by\,\, p\,\, in\,\, T\,\,and\, \,p\,\, \in\, \,PV\}|}{|V(G)|}</script><p><strong>Theorem 6.2.</strong> Given a constant M, finding a pivot set PV to maximize $(\sum_{v\in V(G)}cr(T(v)))$ is a NP-hard problem, where |PV|=M and T(v) denotes the shortest path tree rooted at v.</p></blockquote><p>因此使用一些启发式选择pivots——a high-degree strategy.</p><h2 id="6-3-Further-optimization"><a href="#6-3-Further-optimization" class="headerlink" title="6.3 Further optimization"></a>6.3 Further optimization</h2><p>后期大部分路径都被计算出来，没必要再去load pivot的最短路径树，因此提供了一个终止loading的条件。<br>$Cost_{update}=Count_{update}\times Cost_{CPU}$<br>where $Cost_{CPU}$ is the average CPU cost of a distance update operation.<br>$Cost_{I/O}$ is the average I/O cost of a distance update operation.<br>1) if $Cost_{update}\le Cost_{I/O}$，continue to load pivot’s shortest path tree.<br>2) if $Cost_{update}&gt; Cost_{I/O}$，end loading pivot’s shortest path tree.<br>其中$Cost_{CPU}$和$Cost_{I/O}$是常数。</p><h1 id="7-Experiments"><a href="#7-Experiments" class="headerlink" title="7. Experiments"></a>7. Experiments</h1><p>数据集：DBLP,Yago,DBPedia.<br>Baseline:<br>    (Effectiveness)BANKS,BANKS,Annotated SPARQL.（分别对应三个数据集）<br>    (Efficiency) exhaustive computing（第一节有提到）, Basic Search(Algorithm 1), Pivot-based Search(Algorithm 3)</p><h2 id="7-1-Datasets-and-setup"><a href="#7-1-Datasets-and-setup" class="headerlink" title="7.1 Datasets and setup"></a>7.1 Datasets and setup</h2><p>Our experiments were conducted on a machine with a 2.4 Ghz Core 2 Duo processor and 80G RAM memory.</p><h2 id="7-2-Effectiveness-study"><a href="#7-2-Effectiveness-study" class="headerlink" title="7.2 Effectiveness study"></a>7.2 Effectiveness study</h2><h3 id="7-2-1-Case-Study"><a href="#7-2-1-Case-Study" class="headerlink" title="7.2.1 Case Study"></a>7.2.1 Case Study</h3><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/table3.png"><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/table4-5.png"><h3 id="7-2-2-NDCG-k-over-Yago-and-DBLP"><a href="#7-2-2-NDCG-k-over-Yago-and-DBLP" class="headerlink" title="7.2.2. NDCG@k over Yago and DBLP"></a>7.2.2. NDCG@k over Yago and DBLP</h3><p>NDCG——the normalized discounted cumulative gain。</p><h3 id="7-2-3-MAP-over-Yago-and-DBLP"><a href="#7-2-3-MAP-over-Yago-and-DBLP" class="headerlink" title="7.2.3. MAP over Yago and DBLP"></a>7.2.3. MAP over Yago and DBLP</h3><p>MAP——the mean average precision.<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/table9-10.png"></p><h2 id="7-3-Efficiency-study"><a href="#7-3-Efficiency-study" class="headerlink" title="7.3. Efficiency study"></a>7.3. Efficiency study</h2><h3 id="7-3-1-Pruning-effect-of-the-structure-index"><a href="#7-3-1-Pruning-effect-of-the-structure-index" class="headerlink" title="7.3.1. Pruning effect of the structure index."></a>7.3.1. Pruning effect of the structure index.</h3><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/table11-13.png"><h3 id="7-3-2-Evaluation-of-pivot-selection-methods"><a href="#7-3-2-Evaluation-of-pivot-selection-methods" class="headerlink" title="7.3.2. Evaluation of pivot selection methods"></a>7.3.2. Evaluation of pivot selection methods</h3><h3 id="7-3-3-Evaluation-of-pivot-numbers"><a href="#7-3-3-Evaluation-of-pivot-numbers" class="headerlink" title="7.3.3. Evaluation of pivot numbers"></a>7.3.3. Evaluation of pivot numbers</h3><h3 id="7-3-4-Offline-performance"><a href="#7-3-4-Offline-performance" class="headerlink" title="7.3.4. Offline performance"></a>7.3.4. Offline performance</h3><h3 id="7-3-5-Online-performance"><a href="#7-3-5-Online-performance" class="headerlink" title="7.3.5. Online performance"></a>7.3.5. Online performance</h3><h1 id="8-Related-work"><a href="#8-Related-work" class="headerlink" title="8. Related work"></a>8. Related work</h1><ul><li>SPARQL查询。一些把RDF存储在RDBMS，用join操作回应SPARQL查询。RDF-3x和Hexastore为主谓宾分别创建索引。gStore和AmbER在RDF图中利用子图匹配应答SPARQL，和VF2应答SPARQL查询类似。</li><li>关键词查询。<ul><li>将关键词转换为SPARQL，然后利用SPARQL查询引擎。</li><li>找到包含所有关键词的子结构，如tree，clique，或其他。</li></ul></li><li>挖掘常用pattern建立索引。gIndex，gSpan，GADDI。</li><li>keyword和SPARQL的混合查询。Elbassuoni假定每个三元组都有相联系的文字段落，利用关键词条件扩展SPARQL中的三元组。$CE^2$假定每个资源都有联系的文档，他用关键词条件扩展SPARQL中的变量。但本方法适用范围最广。</li><li>其他。[38]中作者为结构化查询中掺杂关键词查询定义了新的查询语言。Bhagdev和Bikakis尝试使用语义进行关键词查询，邹蕾将自然语言转换成SPARQL查询（读过）。<h1 id="9-Conclusions"><a href="#9-Conclusions" class="headerlink" title="9. Conclusions"></a>9. Conclusions</h1>In this paper, we proposed a new kind of query (the SK query) that integrates SPARQL and keywords. To handle this kind<br>of query, we first introduced a basic method based on backward search. However, this basic solution faces several performance is- sues. Hence, we built a structural index and a distance-based in- dex. Our structural index is based on frequent star patterns in the RDF data, and our distance-based index is based on the shortest path trees of selected pivots in the RDF graph. Using the indices, we propose an advanced strategy to deal with SK queries. Finally, using three real RDF datasets, we demonstrated that our method can outperform the baseline both with respect to effectiveness and efficiency.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ABSTRACT&quot;&gt;&lt;a href=&quot;#ABSTRACT&quot; class=&quot;headerlink&quot; title=&quot;ABSTRACT&quot;&gt;&lt;/a&gt;ABSTRACT&lt;/h1&gt;&lt;p&gt;虽然SPARQL是RDF图上优越的查询语言，但一些查询意图仍无法使用SPARQL句法表达。关
      
    
    </summary>
    
      <category term="论文笔记" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="2017年9月" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/2017%E5%B9%B49%E6%9C%88/"/>
    
  </entry>
  
  <entry>
    <title>《Keyword Search in Graphs: Finding r-cliques》——读书笔记</title>
    <link href="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/08/24/%E3%80%8AKeyword-Search-in-Graphs-Finding-r-cliques%E3%80%8B%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/LiuKaixin/LiuKaixin.github.io/2017/08/24/《Keyword-Search-in-Graphs-Finding-r-cliques》——读书笔记/</id>
    <published>2017-08-24T03:18:00.000Z</published>
    <updated>2017-09-27T08:18:19.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ABSTRCT"><a href="#ABSTRCT" class="headerlink" title="ABSTRCT"></a>ABSTRCT</h1><p>图上的关键词搜索是找到一个包含所有关键词的子结构，之前的工作都是找最小连通图（connected minimal trees），而现在发现找子图比找子树对用户来说更有用。子树中的关键词节点（content nodes）彼此间可能并不紧连，另外，在找子树时会遍历整个图而不仅是关键词节点。<br>An r-clique is a group of content nodes that cover all the input keywords and the distance between each two nodes is less than or equal to r.</p><h1 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1. INTRODUCTION"></a>1. INTRODUCTION</h1><blockquote><p><a href="http://www.morganclaypool.com/doi/pdf/10.2200/S00231ED1V01Y200912DTM001" target="_blank" rel="external">keyword search in databases.</a>是联通子树（这是一本书，我没看。。。）。李国良的文章<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.184.8489&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">Ease: Efficient and adaptive keyword search on unstructured, semi-structured and structured data</a> 的答案是半径不大于r的斯坦纳树。</p></blockquote><p>以前基于树或图的方法存在的问题：</p><ol><li>一些关键词节点（content nodes）相距太远。</li><li>对所有的节点遍历，时间和空间复杂度都很高。</li></ol><p>使用r-cliques的优点：</p><ol><li>所有关键词节点相距很近。</li><li>无需遍历所有节点。</li></ol><p>举例说明：<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Keyword%20search%20in%20graphs%20Finding%20r-cliques/fig1.png"><br><img src="http://ouqbyuben.bkt.clouddn.com/images/Keyword%20search%20in%20graphs%20Finding%20r-cliques/fig2.png"><br>关键词：James, John, Jack。 r=10。<br>图2(a)中的答案比图2(c)中的更加合理，因为三个点在同一个组织。另外三边之和也是图2(a)更小。但是对于用文献<a href="http://dl.acm.org/citation.cfm?id=1547515" target="_blank" rel="external">13</a>生成的两者的斯坦纳树，结果相反。</p><p>本文贡献：</p><ol><li>提出一个新的图关键词搜索的模型。</li><li>证明找到有最小权重的r-clique是NP-hard问题。</li><li>基于Branch和Bound的算法找到所有的r-cliques。</li><li>提出一个找2个近似度的r-cliques的近似算法，能在多项式时间内以升序找到所有的r-clique。</li><li>为了找到某个r-clique中的节点的关系，提出在图中找连接r-clique中节点的斯坦纳树。</li></ol><blockquote><p><a href="http://dl.acm.org/citation.cfm?id=2749447" target="_blank" rel="external">Exact Top-k Nearest Keyword Search in Large Networks</a><br>There are other keyword search problems that are of some different characteristics. The general idea of keyword search is to find a subgraph in a given graph that contains the query keywords.<br>The subgraph can be of the form of a tree in some cases. </p><ul><li>BANKS in [5] converts a relational database into a graph and answers to keyword queries are directed subtrees in the graph. Given a directed graph, the keyword search in [16] returns top ranked subtrees in the graph that cover the query keywords. </li><li>Blinks [18] also considers directed graph and given a keyword query, an answer is a subtree in the graph that covers the keywords and the root of the subtree can reach all the keywords. Top-k results are top k subtrees with different roots. </li><li>The graph type of r-clique is introduced in [21] as the form of expected answers. An r-clique is a set of vertices in the given graph which covers the given query keywords and the distance between any pair of the vertices in this set is no longer than r. Both exact and approximate algorithms have been proposed in [21]. Querying the neighbors of a vertex in a compressed social network is considered in [24]</li></ul><p><a href="http://www.sciencedirect.com/science/article/pii/S0306457314000727#b0155" target="_blank" rel="external">Efficient processing of keyword queries over graph databases for finding effective answers</a>一篇较新的关于树形的文章。</p><ul><li>the minimal Steiner tree semantics.将答案树的权重定义为边的和，所以问题就转化成optimal group Steiner tree problem.有些人用启发式的规则得到l倍近似的结果（l是关键词数目）；有人用dp…但这些方法并不能有效的在大图上得出top-k Steiner tree-stuctured answers.</li><li>distinct root semantics.答案树的权重为根节点到关键词节点的最短路径之和，每个根节点只有权重最小的答案树被作为候选。因此，对于n个点的图，至多有n个答案，所以比斯坦纳树更高效（这里没懂）。</li><li>之前的工作限制着包含一个关键词的节点个数有且只有一个，本文中答案树包含一个关键词的节点可能有多个。</li></ul><p><a href="http://dl.acm.org/citation.cfm?id=3022863" target="_blank" rel="external">Survey on Keyword Search over XML Documents</a>  该文第3章提出对于XML关键词搜索基于图的方法。</p><ol><li>Subtree based Semantics for <strong>Directed</strong> Graphs.<ul><li>the minimal Steiner tree semantics. <a href="http://delivery.acm.org/10.1145/1380000/1376708/p927-golenberg.pdf?ip=166.111.134.52&amp;id=1376708&amp;acc=ACTIVE%20SERVICE&amp;key=BF85BBA5741FDC6E%2E587F3204F5B62A59%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&amp;CFID=882572412&amp;CFTOKEN=29985573&amp;__acm__=1505267509_337f555665e22704b8e4b8b45b2f64af" target="_blank" rel="external">Keyword proximity search in complex data graphs.</a></li><li>the distinct root semantics. <a href="http://dl.acm.org/citation.cfm?id=1247516" target="_blank" rel="external">BLINKS: ranked keyword searches on graphs</a></li></ul></li><li>Subgraph based Semantics for <strong>Undirected</strong> Graphs. (方法的优劣暂且不论，其应用在无向图，但RDF是有向图)<ul><li>r-radius semantics. <a href="http://dl.acm.org/citation.cfm?id=1376706" target="_blank" rel="external">EASE: Efficient and adaptive keyword search on unstructured, semi-structured and structured data.</a>（2008）</li><li>r-clique semantics. <a href="http://dl.acm.org/citation.cfm?id=2021025" target="_blank" rel="external">Keyword search in graphs: finding r-cliques</a>（2011）</li><li>minimum cost connected tree. <a href="http://ieeexplore.ieee.org/abstract/document/4221732/" target="_blank" rel="external">Finding top-k min-cost connected trees in database.</a>（2007）</li></ul></li><li>Bi-directed Tree based Semantics for Directed Graphs<br>BANKS和<a href="http://dl.acm.org/citation.cfm?id=1083652" target="_blank" rel="external">Bidirectional expansion for keyword search on graph databases</a>（2005）返回有前向边或后向边的子树。<a href="http://dl.acm.org/citation.cfm?id=1142377" target="_blank" rel="external">Finding and approximating top-k answers in keyword proximity search</a>返回混合了前向边和后向边的子树。（2006）</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ABSTRCT&quot;&gt;&lt;a href=&quot;#ABSTRCT&quot; class=&quot;headerlink&quot; title=&quot;ABSTRCT&quot;&gt;&lt;/a&gt;ABSTRCT&lt;/h1&gt;&lt;p&gt;图上的关键词搜索是找到一个包含所有关键词的子结构，之前的工作都是找最小连通图（connected m
      
    
    </summary>
    
      <category term="论文笔记" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Keyword" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/Keyword/"/>
    
      <category term="2017年9月" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/2017%E5%B9%B49%E6%9C%88/"/>
    
  </entry>
  
  <entry>
    <title>《Natural Language Question Answering over RDF ——  A Graph Data Driven Approach》——论文笔记</title>
    <link href="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/08/24/%E3%80%8ANatural-Language-Question-Answering-over-RDF-%E2%80%94%E2%80%94-A-Graph-Data-Driven-Approach%E3%80%8B%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/LiuKaixin/LiuKaixin.github.io/2017/08/24/《Natural-Language-Question-Answering-over-RDF-——-A-Graph-Data-Driven-Approach》——论文笔记/</id>
    <published>2017-08-24T03:15:00.000Z</published>
    <updated>2017-09-27T08:18:19.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h1><p>RDF Q/A允许用户对RDF知识库用自然语言提问。为回答该提问，需要两步：理解问题和执行查询。现有工作大都集中在解决自然语言的歧义，通常做法是the joint disambiguation，使搜索空间指数增长。本文从图数据驱动的角度解决该问题，提出使用语义查询图为自然语言的查询意图建模，将问题归约成子图匹配问题。更重要的是，我们通过查询的匹配情况，解决自然语言问题的多义性。实验结果验证算法。</p><h1 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1. INTRODUCTION"></a>1. INTRODUCTION</h1><p>背景：用户需从知识库中获取知识，RDF格式成为标准，SPARQL查询对用户不友好，需要RDF Q/A系统。</p><h1 id="1-1-Motivation"><a href="#1-1-Motivation" class="headerlink" title="1.1 Motivation"></a>1.1 Motivation</h1><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/fig1.png"><p>现在RDF Q/A系统主要分两个阶段：question understanding和query evaluation。第一阶段把自然语言问题N转化成SPARQLs，这也是目前大部分工作的研究重点。第二阶段执行第一阶段得到的SPARQls。如图1所示，(a)是RDF数据集，(b)是目前解决方法的两个步骤，可以看到由于多义性，有些短语对应多个实体。如果同时考虑这些短语则增加了响应时间。<br>本文并不在第一阶段解决多义性问题，而是放到第二阶段，能够避免问题理解阶段的高昂的消歧处理，从而加速整个系统。本方法中最关键的问题在于如何定义RDF图G中的子图和自然语言问题N的匹配，以及如何找到匹配。</p><h2 id="1-2-Our-Approach"><a href="#1-2-Our-Approach" class="headerlink" title="1.2 Our Approach"></a>1.2 Our Approach</h2><p>虽然本方法仍有“question understanding”和“query evaluation”，但并不与现在的SPARQL generation-and-evaluation相同，本方法是graph data-driven，其大概的框架如图1(c)。<br>在question understanding阶段，我们把问题iN翻译为semantic query graph $Q^{S}$。该步允许多义。<br>在query evaluation阶段，我们在图G上找$Q^{S}$的匹配的子图。我们基于语义相似性定义了匹配的分数。<br>将消歧放在query evaluation阶段不仅提高了精度也加速了整个查询应答时间。<br>贡献：</p><ol><li>为问题提出了系统的框架。并从graph data-driven的角度，将消歧放在了query evaluation阶段。</li><li>离线处理：提出图挖掘算法，将短语匹配到top-k个可能的谓词，形成paraphrase dictionary D。</li><li>在线处理：两个阶段，首先将问题N转换为semantic query graph $Q^{S}$，然后把RDF Q/A归约成$Q^{S}$在图G上的子图匹配问题。在找到匹配时解决了多义问题，如果没有匹配发现则消歧的花费就被节省了。</li><li>实验</li></ol><h1 id="2-FRAMEWORK"><a href="#2-FRAMEWORK" class="headerlink" title="2. FRAMEWORK"></a>2. FRAMEWORK</h1><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/table1.png"><p>本问题有两个关键的挑战，一是如何以结构化的方式表示问题N中的查询意图。二是如何处理问题N中的短语的多义性。<br>为解决第一个挑战，我们从N中抽出semantic relations，并基于此建立了semantic query graph $Q^{S}$为问题N中的问题意图建模。</p><blockquote><p>Definition 1. <strong>(Semantic Relation).</strong> A semantic relation is a triple <rel, arg1,="" arg2="">, where rel is a relation phrase in the paraphrase dictionary D, arg1 and arg2 are the two argument phrases.<br>Definition 2. <strong>(Semantic Query Graph)</strong> A semantic query graph is denoted as $Q^S$, in which each vertex $v_i$ is associated with an argument and each edge $\bar{v_iv_j}$ is associated with a relation phrase, $1\le i,j\le |V(Q^{S})|$.    </rel,></p></blockquote><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/fig2.png"><p>针对第二个挑战，我们提出了数据驱动的方法：对于N中一个短语到实体的映射，如果能找到包含该实体的子图且匹配N中的查询意图，那该映射是正确的；否则是错误的。</p><h2 id="2-1-Offline"><a href="#2-1-Offline" class="headerlink" title="2.1 Offline"></a>2.1 Offline</h2><p>建立了paraphrase dictionary D——记录语义相等的关系短语和谓词。一些现有的系统如Patty和ReVerb还未每个关系短语提供了其支持的实体对，如表2。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/table2.png"><br>方法思路：对每个关系短语$rel_i$，$Sup(rel_i)$表示一系列该谓词支持的实体对。我们假设这些实体对也出现在RDF图中。频繁出现的谓词连接$Sup(rel_i)$中的实体对和关系短语$rel_i$等价。基于该想法我们提出一个找语义相等的关系短语和谓词的图挖掘算法。</p><h2 id="2-2-Online"><a href="#2-2-Online" class="headerlink" title="2.2 Online"></a>2.2 Online</h2><p>1) <em>Question Understanding. </em>目的在于为问题N构建一个语义查询图$Q^{S}$。首先用Stanford Parser得到N的依赖树Y，然后基于paraphrase dictionary D抽取Y中的语义关系。基本的思路是找到一个Y的包含rel的所有词的最小子树。该子树被称为Y中的rel的一个嵌入，并且基于一些语言规则我们得到有联系的两个参数，形成$&lt; rel,arg1,arg2 &gt;$，最后连接这些关系得到查询图$Q^{S}$。<br>2) <em> Query Evaluation. </em>找到与$Q^{S}$匹配的子图。匹配按照子图同态定义。    </p><p>首先，$Q^{S}$的点，被映射到RDF图中的一些实体或类，并赋予一个置信度，保存在有序列表$C_{v_i}$。关系短语$rel_{\overline{v_iv_j}}$被映射到候选谓词的列表$C_{\overline{v_iv_j}}$中。列表以置信度排序。本步中并没有解决多义问题。<br>其次，</p><blockquote><p>Definition 3.<strong>(Match)</strong> Consider a semantic query graph $Q^{S}$ with n vertices $\{v_1,…,v_n\}$. Each vertex $v_i$ has a condidate list $C_{v_i},i=1,…,n.$ Each edge $\overline{v_iv_j}$ also has a candidate list of $C_{\overline{v_iv_j}}, where $1\le i\ne j\le n.$ A subgraph M containing n vertices $\{u_1,…,u_n\}$ in RDF graph G is a match of $Q^{S}$ if and only if the following conditions hold: </p><ol><li>if $v_i$ is mapping to an entity $u_i$, i=1,…,n, $u_i$ must be in list $C_{v_i}$;</li><li>if $v_i$ is mapping to a class $c_i$, i=1,…,n, $u_i$ is an entity whose type is $c_i$ (i.e., there is a triple &lt;$u_i$ rdf:type $c_i$&gt; in RDF graph) and $c_i$ must be in $C_{v_i}$;</li><li>$\forall \overline{v_iv_j}\in Q^S; \, \overrightarrow{u_iu_j}\in G \lor  \overrightarrow{u_ju_i}\in G$. Furthermore, the predicate $P_{ij}$ associated with $\overrightarrow{u_iu_j}$ (or $\overrightarrow{u_ju_i}$ is in $C_{\overline{v_iv_j}},\, 1\le i,j\le n$.</li></ol></blockquote><p>每个和$Q^S$匹配的子图都有一个得分，由边和点的概率决定。我们的目标是找到top-k个匹配的子图，在4.2.2节中解决。</p><h1 id="3-OFFLINE"><a href="#3-OFFLINE" class="headerlink" title="3. OFFLINE"></a>3. OFFLINE</h1><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/fig3.png"><p>语义关系抽取依赖于词典D，图3是词典的一个示例。本文并不讨论如何抽取短语及其对应的实体对，假设已经给定。<br>在offline中的任务是找到语义相等的关系短语和RDF中的相应谓词，即构建如图3的词典D。假设已有词典$T=\{rel_1,…,rel_n\}$，每个$rel_i$都是一个关系短语，并有一个出现在RDF图中的实体对集合，即$Sup(rel_i)=\{(v^1_i,V^{‘1}_i),…,(v^m_i,V^{‘m}_i),\}$。对于每个$rel_i$目标是找到RDF图中的top-k个语义相等的谓词（路径）。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/fig4.png"><br>方法：给定一个关系短语$rel_i$及$Sup(rel_i)=\{(v^1_i,V^{‘1}_i),…,(v^m_i,V^{‘m}_i),\}$，对$(v^j_i,V^{‘j}_i),j = 1,…,m$，我们在RDF图中找到两点间的简单路径：$Path(v^j_i,V^{‘j}_i)$，如图4。则$PS(rel_i)=\bigcup_{j=1,…,m}Path(v^j_i,V^{‘j}_i)$.    为了效率，我们设定了路径的阈值，然后使用双向的BFS搜索找到$Path(v^j_i,V^{‘j}_i)$。<br>但是这样的方法会带来噪音，解决方法：采用了tf-idf度量。</p><blockquote><p>Definition 4. Given a predicate path L, the tf-value of L in $PS(rel_i)$ is defined as follows:    </p><script type="math/tex; mode=display">tf(L,PS(rel_i))=|\{Path(v^j_i,V^{'j}_i)| L\in Path(v^j_i,V^{'j}_i)\}|</script><p>The idf-value of L over the whole relation phrase dictionary $T=\{rel_1,…,rel_n\}$ is defined as follows:</p><script type="math/tex; mode=display">idf(L,T)=log \frac{|T|}{|\{rel_i\in T|L \in PS(rel_i)\}|+1}</script><p>The tf-idf value of L is defined as follows:</p><script type="math/tex; mode=display">tf-idf(L,PS(rel_i),T)=tf(L,PS(rel_i))\times idf(L,T)</script></blockquote><p>关系短语和谓词（路径）的置信度定义为：</p><script type="math/tex; mode=display">\delta (rel,L)=tf-idf(L,PS(rel_i),T) \tag{1}</script><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/alg1.png"><p>算法1展示了为每个关系短语找top-k谓词路径的细节。注意tf-idf is a probability value to evaluate the mapping (from relation phrase to predicate/predicate paths) confidence.<br>维护D只需要为新引入的谓词重新挖掘映射，或删除被移除数据集的谓词的映射。</p><blockquote><p>Theorem 1. The time complexity of Algorithm 1 is $O(|T|\times |V|^2\times d^2)$, where |T| is the number of relation phrases in T, |V| is the number of vertices in RDF graph G, and d is the maximal vertex degree.</p></blockquote><h1 id="4-ONLINE"><a href="#4-ONLINE" class="headerlink" title="4. ONLINE"></a>4. ONLINE</h1><h2 id="4-1-Question-Understanding"><a href="#4-1-Question-Understanding" class="headerlink" title="4.1 Question Understanding"></a>4.1 Question Understanding</h2><p>本节讨论如何识别问题N中的语义关系，并基于关系建立语义查询图$Q^S$代表N中的查询意图。<br>为抽取句子关系短语，建立依赖树。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/fig5.png"><br>图5展示了问题N的依赖树表示为Y。</p><blockquote><p>Definition 5. Let us consider a dependency tree Y of a natural language question N and a relation phrase rel. We say that rel occurs in Y if and only if there exists a connected subtree y (of Y) satisfying the following conditions:</p><ol><li>Each node in y contains one word in rel and y includes all words in rel.</li><li>We cannot find a subtree $y^{‘}$ of Y, where $y^{‘}$ also satisfies the first condition and y is a subtree of $y^{‘}$.<br>In this case, y is an embedding of relation phrase rel in Y.</li></ol></blockquote><p>给定问题N的依赖树Y和关系短语词典$T=\{rel_1,…,rel_n\}$，我们需要T中那个关系短语在Y中出现。</p><h3 id="4-1-1-Finding-Relation-Phrase-Embeddings"><a href="#4-1-1-Finding-Relation-Phrase-Embeddings" class="headerlink" title="4.1.1 Finding Relation Phrase Embeddings"></a>4.1.1 Finding Relation Phrase Embeddings</h3><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/alg2.png"><blockquote><p>Theorem 2. The time complexity of Algorithm 2 is $O(|Y|^2)$.</p></blockquote><h3 id="4-1-2-Finding-Associated-Arguments"><a href="#4-1-2-Finding-Associated-Arguments" class="headerlink" title="4.1.2 Finding Associated Arguments"></a>4.1.2 Finding Associated Arguments</h3><p>通常参数的识别依赖subject-relations、object-like relations，如下：</p><ol><li>subject-like relations: sbj, nsubj, nsubjpass, csubj, csubj-pass, xsubj, poss;</li><li>object-like relations: obj,pobj, dobj, iobj</li></ol><p>假设关于短语rel的嵌入子树为y。通过检查y中的每个节点w及其子节点是否出现以上的subject-like（object-like）关系，出现则把子节点加入到arg1（arg2）。<br>如果arg1/arg2仍是空，我们有以下启发式规则：</p><ul><li>Rule 1: Extend the embedding t with some light words, such as prepositions, auxiliaries. Recognize subject/object-like relations for the newly added tree node.</li><li>Rule 2: If the root node of t has subject/object-like relations with its parent node in Y, add the root node to arg1.</li><li>Rule 3: if the parent of the root node of t has subject-like relations with its child, add the child to arg1.</li><li>Rule 4: If one of arg1/arg2 is empty, add the nearest wh-word (such as what, who and which) or the first noun phrase in t to arg1/arg2.     </li></ul><p>如果arg1/arg2仍然是空，则放弃关系短语rel。</p><h3 id="4-1-3-Building-Semantic-Query-Graph"><a href="#4-1-3-Building-Semantic-Query-Graph" class="headerlink" title="4.1.3 Building Semantic Query Graph"></a>4.1.3 Building Semantic Query Graph</h3><p>把语义关系<rel,arg1,arg2>表示为边，如果两个关系的参数相同，则边相连。</rel,arg1,arg2></p><h2 id="4-2-Query-Evaluation"><a href="#4-2-Query-Evaluation" class="headerlink" title="4.2 Query Evaluation"></a>4.2 Query Evaluation</h2><h3 id="4-2-1-Phrases-Mapping"><a href="#4-2-1-Phrases-Mapping" class="headerlink" title="4.2.1 Phrases Mapping"></a>4.2.1 Phrases Mapping</h3><p>讨论如何将关系短语和参数映射到候选的谓词（路径）和实体。<br><strong>Mapping edges of $Q^S$.</strong> $Q^S$中边$\overline{v_iv_j}$对应关系短语$rel_{\overline{v_iv_j}}$。按照paraphrase dictionary D，$rel_{\overline{v_iv_j}}$映射到列表$C_{\overline{v_iv_j}}$，列表中是谓词P或谓词路径L。$\delta(rel,L)$置信度。<br><strong>Mapping Vertices of $Q^S$.</strong>  $Q^S$中点v对应参数arg。如果arg是wh-word，则它可映射到RDF中所有实体和类，否则返回一个对应的实体或类的列表。本文使用现成的工具DBpedia Lookup。$\delta(arg,c)$置信度。<br><strong>Graph Data-driven Disambiguation.</strong> graph data-driven solution.</p><h3 id="4-2-2-Finding-top-k-Subgraph-Matches"><a href="#4-2-2-Finding-top-k-Subgraph-Matches" class="headerlink" title="4.2.2 Finding top-k Subgraph Matches"></a>4.2.2 Finding top-k Subgraph Matches</h3><blockquote><p>Definition 6. Given a semantic query graph $Q^S$ with n vertices $\{v_1,…,v_n)\}$, a subgraph M containing n vertices $\{u_1,…,u_n\}$ in RDF graph G is a match of $Q^S$. The match score is defined as follows:    </p><script type="math/tex; mode=display">Score(M)=log( \prod_{v_i\in V(Q^S)} \delta (arg_i,u_i) \times \prod_{\overline{v_iv_j}\in E(Q^S)} \delta (rel_{\overline{v_iv_j}},P_{ij})  )\\=\sum_{v_i\in V(Q^S)} log( \delta (arg_i,u_i))+\sum_{\overline{v_iv_j}\in E(Q^S)} log( \delta (rel_{\overline{v_iv_j}},P_{ij})  ) \tag{2}</script><p>where $arg_i$ is the argument of vertex $v_i$, and $u_i$ is an entity or a class in RDF graph G, and $rel_{\overline{v_iv_j}}$ is the relation phrase of edge $\overline{v_iv_j}$ and $P_{ij}$ is a predicate of edge $\overrightarrow{u_iu_j}$ or $\overrightarrow{u_ju_i}$</p></blockquote><p>给定语义查询图$Q^S$，我们目标是找到$Q^S$的所有匹配中分数top-k的。这是个NP-hard问题。</p><blockquote><p>Lemma 1. Finding Top-1 subgraph match of $Q^S$ over RDF graph G is an NP-hard problem.<br>Lemma 2. Finding Top-k subgraph match of $Q^S$ over RDF graph G is at least as hard as finding Top-1 subgraph match of $Q^S$ over G.<br>Theorem 3.  Finding Top-k subgraph match of $Q^S$ over RDF graph G is an NP-hard problem.</p></blockquote><p>因为他是NP-hard问题，所以我们设计启发式规则减少搜索空间。第一个利用neighborhood-based pruning减少$C_{v_i}$和$C_{\overline{v_iv_j}}$。第二个是基于top-k匹配的分阈值及早停止搜索。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/alg3.png"></p><h1 id="5-TIME-COMPLEXITY-ANLYSIS"><a href="#5-TIME-COMPLEXITY-ANLYSIS" class="headerlink" title="5. TIME COMPLEXITY ANLYSIS"></a>5. TIME COMPLEXITY ANLYSIS</h1><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/table3.png"><h1 id="6-EXPERIMENTS"><a href="#6-EXPERIMENTS" class="headerlink" title="6. EXPERIMENTS"></a>6. EXPERIMENTS</h1><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/table4-5.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ABSTRACT&quot;&gt;&lt;a href=&quot;#ABSTRACT&quot; class=&quot;headerlink&quot; title=&quot;ABSTRACT&quot;&gt;&lt;/a&gt;ABSTRACT&lt;/h1&gt;&lt;p&gt;RDF Q/A允许用户对RDF知识库用自然语言提问。为回答该提问，需要两步：理解问题和执行查
      
    
    </summary>
    
      <category term="论文笔记" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="RDF" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/RDF/"/>
    
      <category term="2017年8月" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/2017%E5%B9%B48%E6%9C%88/"/>
    
      <category term="QA" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/QA/"/>
    
  </entry>
  
  <entry>
    <title>《Scalable Keyword Search on Large RDF Data》——论文笔记</title>
    <link href="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/08/20/%E3%80%8AScalable-Keyword-Search-on-Large-RDF-Data%E3%80%8B%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/LiuKaixin/LiuKaixin.github.io/2017/08/20/《Scalable-Keyword-Search-on-Large-RDF-Data》——论文笔记/</id>
    <published>2017-08-20T05:10:00.000Z</published>
    <updated>2017-09-27T08:18:19.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>目前关键词搜索的两种方法：一、依赖建立距离矩阵来剪枝搜索空间，二、为RDF图建立摘要。本文指出现有技术面对真实数据集时的不足，并且提出一个新的摘要算法，能够更有效的剪枝并得到正确的答案。</p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><ul><li>动机：RDF数据急速增长。关键词搜索对大规模数据十分有用，目前对于RDF数据的解决方法的局限：<ul><li>返回不正确的答案。</li><li>难以处理大规模RDF数据。    </li></ul></li><li>目标：设计一个能处理大规模RDF数据集的scalable and exact soluton。</li><li>贡献：<ul><li>identify and address limitations in the existing methods for keyword search in RDF data. 并基于后向搜索提出一个正确的baseline解法。</li><li>develop efficient algorithms to summarize the structure of RDF data, based on the types in RDF graohs. 和之前的方法相比more scalable剪枝也更有意义，并且得到的摘要是轻量级的而且可更新。</li><li>experiments on both benchmark and large real RDF datasets.</li></ul></li></ul><h1 id="2-Preliminaries"><a href="#2-Preliminaries" class="headerlink" title="2 Preliminaries"></a>2 Preliminaries</h1><p>将RDF数据集看做RDF图G=(V,E)其中</p><ul><li>$V=\{V_E,V_T,V_W\}$<ul><li>$V_E$: the set of entity vertices.</li><li>$V_T$: the set of type vertices.    </li><li>$V_W$: the set of keyword vertices.    </li></ul></li><li>$E=\{E_R,E_A,E_T\}$<ul><li>$E_R$: the set of entity-entity edges.</li><li>$E_A$: the set of entity-keyword edges.</li><li>$E_T$: the set of entity-type edges.</li></ul></li></ul><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig1.png">    <p>图1中主要结构被entity-entity edge即$E_R$捕获，因此将entity vertex和关于他的type vertex和keyword vertex看做一个点，我们得到RDF图G的压缩视图，表示为$G_c=\{V^{‘}_E,E_R\}$。其中$|V^{‘}_E| \equiv |V_E|$，$v^{‘}\in V^{‘}_E$包含$v\in V_E$和与之联系的类型和关键词节点。</p><h2 id="2-1-Problem-statement"><a href="#2-1-Problem-statement" class="headerlink" title="2.1 Problem statement"></a>2.1 Problem statement</h2><p>关键词查询问题即RDF图中寻找包含所有关键词的子图。<br>为便于表示，假设每个节点只包含一个关键词。（但对于包含多个和不包含的也能处理）<br>对在$G=\{V,E\}$上的查询$q=\{w_1,w_2,…,w_m\}$，点集$\{r,v_1,…,v_m\}$在以下条件成立时被称为 qualified candidate:</p><ul><li>root answer node $r\in V$能够到达任一点$v_i\in V,\, i\in [1,m]$</li><li>$w(v_i)=w_i$</li></ul><p>A(q): the answer for q<br>C(q): the set of all qualified candidates in G with respect to q.    </p><script type="math/tex; mode=display">A(q)= arg min_{g\in C(q)}s(g), \, and \, s(g)=\sum_{r,v_i\in g, i=1..m}d(r,v_i)\tag{1}</script><p>其中$d(r,v_i)$是从r到$v_i$的距离（不考虑边方向）。</p><p>该定义还有一个top-k版本，其中对每个$g\in C(q)$的得分s(g)进行升序排列，得到前k个答案。</p><h1 id="3-Related-work"><a href="#3-Related-work" class="headerlink" title="3 Related work"></a>3 Related work</h1><p>许多技术假设图能够在内存中处理，如<a href="http://dl.acm.org/citation.cfm?id=1247516" target="_blank" rel="external">14</a> <a href="http://dl.acm.org/citation.cfm?id=1247516" target="_blank" rel="external">17</a>为所有的点对保存了距离矩阵。另外这些工作不考虑如何处理更新。本文中我们将后向搜索应用于大RDF图并经过严密的证明，不依赖于距离矩阵。<br>关于摘要大图来支持关键词搜索的技术来自于[9]，作者假设块之间的边是有权重的，块被当做supernode，块之间的边被当做superedges，它们组成摘要图。然后循环此过程。该方法针对通用图，并不能拓展到RDF图中。<br>[23]研究了RDF图上的关键词搜索，和本文一样，其调整了[14]中的问题定义。该方法从RDF数据集中摘要出schema，在schema中应用后巷搜索得到最有可能的关系，然后将关系转化为SPARQL中的pattern进行检索。<br>[23]中摘要算法的局限：将同一类型的所有实体归结到一个点，丢失了太多信息，以至于产生错误结果。另外该方法不支持更新。<br>[18]中通过对异质关系编码为图，支持结构化，半结构化和非结构化的关键词查询。同样的，他也需要距离矩阵。<br><a href="https://link.springer.com/chapter/10.1007/978-3-642-25073-6_13" target="_blank" rel="external">11</a> <a href="http://dl.acm.org/citation.cfm?id=1376708" target="_blank" rel="external">12</a>研究了排序函数。我们则是调整了RDF[23]和通用图[14]中的排序函数。</p><h1 id="4-The-Baseline-Method"><a href="#4-The-Baseline-Method" class="headerlink" title="4 The Baseline Method"></a>4 The Baseline Method</h1><p>baseline基于“backward search”的启发式。<br>“backward search”：图中对应关键词查询的所有节点同时开始，迭代地想邻居节点拓展，直到候选答案生成。<em>termination condition</em>用来判断搜索过程是否完成。<br>[23]中的termination condition是当m个节点第一次遇到节点r时返回答案并停止搜索，但该方法并不正确。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig5.png"><br><strong>Counter example. </strong>对于图a来说，第二轮迭代得到$g=\{r=v_4,v_1,v_2,v_6,v_7\}\, \, s(g)=8$，但第四轮迭代中$g^{‘}=\{r=v_3,v_1,v_2,v_6,v_7\}\, \, s(g^{‘})=6$。<br><strong>The correct termination.</strong> 如算法1.<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/alg1.png"><br><em>Data structure. </em><br>$q=\{w_1,…w_m\}$: query<br> G=\{V,E\}: a (condensed) RDF graph<br> $W_i$: vertices in V containing the keyword $w_i$<br> $\{a_1,…a_m\}$: m empty priority queues, one for each query keyword.<br> M: 集合中每个元素对应目前探索到的独一无二的node，记录他们能够到达那个关键词以及距离。对于fig5(a)，$M[v_3]=\{(v_1,1),(v_2,1),nil,(v_7,1)\}$<br><em>The algorithm. </em>(图片中是不是line10,11写错了？）<br>第一轮迭代算是初始化$a_i$和M。$W_i$中每个v和其邻居u放入$a_i$中，并新建$M[u]$或更新$M[u]$的相应值。<br>第二轮迭代首先pop$a_i$的堆顶值，然后添加 $(v,p=\{v,…,u\},d(p))\}$中u的每个邻居$u^{‘}$。将 $(v,p=\{v,…,u^{‘}\},d(p)+1)\}$压入$a_i$然后更新$M[u^{‘}]$。<br>如果$M[u]$没有nil，则该条被标记为候选答案，u为候选根节点。将M[u]中的最短路径表示为g，我们有：</p><blockquote><p><strong>Lemma 1 </strong> $g=\{r=u,v_{l_1},…,v_{l_m}\}$ is a condidate answer with $s(g)=\Sigma^m_{i=1}d(u,v_{l_i})$.</p></blockquote><p>两种情况：(i) an unseen vertex, i.e., $v\notin M$, will become the answer root(Lemma 2); (ii) a seen but not fully expanded vertex $v\in M$ will become the answer root(Lemma 3).<br>$V_t$: the set of vertices that are not fully explored.<br>$(v_1,p_1,d(p_1)),…(v_m,p_m,d(p_m))$: the top entries from $a_1…a_m$.</p><blockquote><p><strong>Lemma 2</strong> Denote the best possible candidate answer as $g_1$, and a vertex $v\notin M$ as the answer root of $g_1$. Then it must have $s(g_1)&gt;\Sigma^m_{i=1}d(p_i)$.<br><strong>Lemma 3</strong> Suppose the best possible candidate answer using such an $v(v\in M\, and \, v\in V_t)$ as the answer root is $g_2$ then    </p><script type="math/tex; mode=display">s(g_2)>\sum^m_{i=1}f(v_{b_i})d_i + (1-f(v_{b_i}))d(p_i) \tag{2}</script><p>where $f(v_{b_i})=1$ if $M[v][b_i]\neq nil$, and $f(v_{b_i})=0$ otherwise.</p></blockquote><p><strong>The termination condition.</strong> 对于情况(i)，我们简单的让$s(g_1)=\Sigma ^m_{i=1}d(p_i)$;对于情况(ii)，we find a vertex with the smallest possible $s(g_2)$ value w.r.t. the RHS of (2), and simply denote its best possible score as $s(g_2)$.<br>Denote the kth smallest candidate answer identified in the algorithm as g, our search can safely terminate when $s(g)\le min(s(g_1),s(g_2))=s(g_2)$. </p><blockquote><p><strong>Theorem 1</strong> The Backward method finds the top-k answers A(q,k) for any top-k keyword query q on RDF graph.</p></blockquote><h1 id="5-Type-Based-Summarization"><a href="#5-Type-Based-Summarization" class="headerlink" title="5 Type-Based Summarization"></a>5 Type-Based Summarization</h1><p>Backward方法对大的RDF图不适用，因为Backward为完成搜索，会构建无数的搜索路径。为了减少Backward算法的输入规模，只在有希望的子图上应用。我们提出了一个type-based摘要方法，即先在摘要图上进行关键词搜索，剪枝掉大部分无用的结果，然后再应用Backward。<br><strong>The intuition.</strong> 首先对RDF图分区，被查询的关键词首先由分区连接。挑战在于如何对不会产生top-k跨区答案进行剪枝。要做到这个我们需要对跨越分区的后向搜索的路径距离进行校正。但维护所有路径的距离成本太高，因此我们提取一个可更新的摘要图，使得任何后向搜索可以被有效地估计。<br>The key observation: 紧邻的相同类型邻居节点一般共享相似的结构——和其他类型的节点的连接，如fig6。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig6.png"><br>我们基于以上观察构建一个typed-based summary。</p><h2 id="5-1-Outline-and-preliminaries"><a href="#5-1-Outline-and-preliminaries" class="headerlink" title="5.1 Outline and preliminaries"></a>5.1 Outline and preliminaries</h2><p>首先将RDF图划分为多个小的区，然后定义摘要了分区的type-baseed structures。摘要保存所有分区的不同结构。通常关键词搜索在两方面受益于摘要：    </p><ul><li>we can obtain the upper and lower bounds for the distance traversed in any backward expansion without constructing the actual path (Section 6).</li><li>we can efficiently retrieve every partition from the data by collaboratively using SPARQL query and any RDF store without explicity storing the partition (Section 15).</li></ul><p>两个定义：<br><strong>Homomorphism across partitions. </strong> 如图6(a)所示，邻近的类型节点是生成induced partitions的好的源头。图6(a)是图6(b)的子集。We consider discovering such embeddings between the induced partitions, so that one template can be reused to bookkeep multiple structures.    </p><blockquote><p><strong>Definition 1</strong> A graph homomorphism f from a graph $G=\{V,E\}$ to a graph $G^{‘}=\{V^{‘},E^{‘}\}$, writtern as $f: G\rightarrow G^{‘}$, is a mapping function $f: V\rightarrow V^{‘}$ such that(i) f(x)=x indicates that x and f(x) have the same type; (ii) $(u,v)\in E$ implies $(f(u),f(v)) \in E^{‘}$ and they have the same label. When such an f exists, we say G is homomorphic to $G^{‘}$.    </p></blockquote><p><strong>Cores for indeividual partitions.</strong> A <em>core</em> is a graph that is only homomorphic to itself, but not to any one of its proper subgraphs.<br><strong>Definition 2</strong> A core c of a graph G is a graph with the following properties: there exists a homomorphism from c to G; there exists a homomorphism from G to c; and c is minimal with these properties.<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig7.png">    </p><h2 id="5-2-Partition"><a href="#5-2-Partition" class="headerlink" title="5.2 Partition"></a>5.2 Partition</h2><p>摘要过程开始于将数据分成较小的，语义相似的，边不相交的子图。鉴于我们观察到相同类型的节点共享相似的类型邻居，我们基于类型用环绕相同类型节点的子图对G划分。算法使用RDF的condensed视图。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/alg2.png"><br>$\{T_1,…,T_n\}$: n distinct number of types.<br>$V_i$vertices whose type is $T_i$.<br>h(v,$\alpha$)(the $\alpha$-neighborhood of v): the subgraph from G obtained by expanding v with $\alpha$ hops.    拓展时的边不在P中，且是有向图，所以h(v,$\alpha$)是v $\alpha$跳邻居节点的子集。<br>P：初始化为空，然后每个h(v,$\alpha$)都是一个新的划分。    </p><blockquote><p><strong>Lemma 4</strong> Partitions in P are edge disjoint and the union of all partitions in P cover the entire graph G.</p></blockquote><p>我们遍历类型的顺序不同可能会影响分区P的最终结果。但无论怎样，同种类型的节点总是基于其$\alpha$-neighborhoods生成一系列划分。如图8。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig8.png">    </p><h2 id="5-3-Summarization"><a href="#5-3-Summarization" class="headerlink" title="5.3 Summarization"></a>5.3 Summarization</h2><p>摘要算法从P的分区集合中识别出一系列templates。这些templates是partitions 的摘要。另外摘要算法保证P中的每个分区都与某个templates同态。该特性是的查询优化器：</p><ol><li>不用频繁访问RDF数据的前提下有效地在后向拓展时估计路径长度。</li><li>通过查询RDF数据来有效地重构感兴趣的分区，而不显式地存储和索引分区。</li></ol><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/alg3.png">    <p>给定一个分区P，算法3检索出所有的不同的结构并将其保存在S中。<br><strong>Improving efficiency and reducing |S|.</strong><br>算法3的两个问题：(1)在3,5,7行需要判断同态，这是NP-hard问题。(2) 尽量减少|S|的大小，以便能够放入内存中处理。<br>对$h(v,\alpha)$的边建立一个covering tree，即$h_t(v,\alpha)$。并用$h_t(v,\alpha)$代替$h(v,\alpha)$。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig9.png"><br><strong>Example 2. </strong>图9中，$h(v_1,2)$$中$v_4$节点在不同边中被访问了三次，所以有三个拷贝。<br>该方法的优点：</p><ul><li>降低S中不同结构的数量，如图9所示，两个在数据层面不同的结构，在类型层面共享一个结构。</li><li>对于通用图来说，检测子图同态十分耗时。但能在多项式时间内检测类型层面的结构。</li></ul><h2 id="5-4-Auxiliary-indexing-structures"><a href="#5-4-Auxiliary-indexing-structures" class="headerlink" title="5.4 Auxiliary indexing structures"></a>5.4 Auxiliary indexing structures</h2><p>为了帮助关键词搜索，我们维护了三个辅助列表。<br>a portal node：node that isincluded in more than one partitions. <em>portal index</em> for each partition $h(v,\alpha)$, 我们赋予其唯一id并和portal列表联系。<br>$\sigma (v_i)$: 表示$h_t(v,\alpha)$中的所有$v_i$。$\Sigma=\{\sigma (v_1),\sigma(v_2),…\}$：表示一个分区中所有的一对多的映射。如图9中，$h(v_1,2)$$\Sigma \leftarrow \{\sigma (v_4)=\{T_4\}\}$. <em>partition index</em>: to map the partition root v of $h(v,\alpha)$ to its $\Sigma$.<br><em>summary index</em>: 将partitions中的节点映射到S中的摘要节点。sid: S中的每个摘要的id，nid: S中每个节点的id。<br>为了获得每个$h_t(v,\alpha)$到S中的summary的映射，需要建立日志保存建立S时的发现的所有同态。等S建立完成后我们遍历日志找到所有从数据到summary的映射。过程如图10.<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig10.png">    </p><h1 id="6-Keyword-search-with-summary"><a href="#6-Keyword-search-with-summary" class="headerlink" title="6 Keyword search with summary"></a>6 Keyword search with summary</h1><p>搜索算法，摘要层和数据层的两级后向搜索。只有摘要层中被识别的connected partitions包含所有关键词，并且其分数在top-k，才会进入数据层执行后向搜索。路径长度计算是后向搜索和剪枝的核心，但摘要层并不能拿到准确的路径长度，因此首先展示如何估计路径长度，然后介绍算法。</p><h2 id="6-1-Bound-the-shortest-path-length"><a href="#6-1-Bound-the-shortest-path-length" class="headerlink" title="6.1 Bound the shortest path length"></a>6.1 Bound the shortest path length</h2><p>通过summary index，分区根节点v到分区内任一节点u的最短距离可计算，所以由三角形不等式得：$|d(v,v_1)-d(v,v_2)|\le d(v_1)-d(v_2)\le |d(v,v_1)+d(v,v_2)|$。另外，另一个下界可用根节点v所在分区的同态的摘要图得到，即Lemma 5：</p><blockquote><p><strong>Lemma 5</strong> Given two graphs g and h, if $f:g\rightarrow h$, then $\forall v_1,v_2\in g$ and their homomorphic mappings $f(v_1),f(v_2)\in h,\, d(v_1,v_2)\le d(f(v_1),f(v_2))$.</p></blockquote><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig11.jpg">    <p>如图11，从h到s没有直接的同态，因此不能直接应用Lemma 5。定义映射函数Join。输入：图g，$\{V^{‘}_{t_1},V^{‘}_{t_2},…\}$。输出：新图$g^{‘}=Join(g(V,E),\{V^{‘}_{t_1},V^{‘}_{t_2},…\})$。其中$V^{‘}_{t_i}$中的点都属于类型$t_i$。函数流程：</p><ol><li>用g初始化$g^{‘}$；</li><li>将$g^{‘}$中的$V^{‘}_{t_i}$合并至类型为$t_i$的点$v^{‘}_{i}$，点集$V^{‘}_{t_i}$中的所有边也赋于$v^{‘}_{i}$；</li><li>对所有类型重复步骤2。</li></ol><p><strong>Example 3. </strong>以图9为例，$Join(h_t(v_1,2),\{\Sigma(T_4)\})$重建了$h(v_1,2)$，因此两者同态。另外，$Join(h_t(v_5,2),\{\Sigma(T_4)\})$没有重建$h(v_5,2)$，但等于$h(v_1,2)$也和$h(v_5,2)$同态。</p><blockquote><p><strong>Lemma 6</strong> For a partition h and its covering tree $h_t$, there is a homomorphism from h to $Join(h_t,\Sigma)$.<br><strong>Lemma 7</strong> For a partition h, its covering tree $h_t$ and its summary s that has $f_2:h_t\rightarrow s$, there is a homomorphism from $Join(h_t,\Sigma)$ to $Join(s,f_2(|Sigma))$.</p></blockquote><p>如图11b，由Lemmas 6,7和同态的可传递性，h is homomorphic to $Join(s,f_2(\Sigma))$。其中$f_2$是summary index的一部分，将数据中的节点映射到摘要中的节点。最后，给定h中任意两点，其最短路径可有Lemmas 5,6,7和最短路径算法在$Join(s,f_2(\Sigma))$中找到最短路的一个下限。实际应用中，我们从summary和三角不等式中找一个更高的下限。</p><h2 id="6-2-The-algorithm"><a href="#6-2-The-algorithm" class="headerlink" title="6.2 The algorithm"></a>6.2 The algorithm</h2><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/alg4.png">    <p><strong>Data structures. </strong><br>$q=\{w_1,…w_m\}$: query<br> G=\{V,E\}: a (condensed) RDF graph<br> $W_i$: vertices in V containing the keyword $w_i$<br> $\{a_1,…a_m\}$: m empty priority queues, one for each query keyword.<br> M: 集合中每个元素对应目前探索到的独一无二的node，记录他们能够到达那个关键词以及历经的分区。M中每个条目是四元组$(u,S,d_l,d_u)$。u是后向搜索中包含关键$w_i$的第一个节点。S存储搜索过程中路径的一系列partitions及其portal（exit node），因此S是(portal, partition root)的集合。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig12.png"><br><strong>The algorithm. </strong></p><ul><li><em>In the first iteration. </em>对于每个来自$W_i$的点u，我们从summary index对u所述的分区根节点v检索。并将检索结果插入M和$a_i$中。</li><li><em>In the j-th iteration.</em> 从所有的$a_i$中pop出最小的条，即$(v,(u,S,d_l,d_u))$(line 10). v是当前分区的根节点。S中最后的对是$(l,v_l)$：路径在$v_l$点离开根为$v_l$的分区并进入现分区。$\mathcal{L}=\{\mathcal{l}^{‘}_1,\mathcal{l}^{‘}_2,…\}$表示根节点为v的分区的portals。对于每个$l^{‘}$按照6.1节的方法计算$d(l,l^{‘})$或$d(u,l^{‘})$的上下限。然后第14行更新，其中$v_r$是与$l^{‘}$相连的下一个分区的根节点。M只有在两种情况下停止更新：(i)S的路径产生了环。(ii)$d_l+d^{‘}_l$比当前第i个列表中第k大的上限还要大。    如果M[v]的所有条目非空，则以v为根节点的分区是候选答案。将m个关键词对应的列表组合起来就是联通子图。    然后我们拿到所选分区的实际数据（如何拿到在第7节），进行二级搜索。</li><li><em>Termination condition. </em>Lemma 8,9.    </li></ul><blockquote><p><strong>Lemma 8</strong> Denote an entry in the priority queue as $(v,(u,S,d_l,d_u))$, then for any $v^{‘}$ in the partition rooted at v and the length of any path starting from u and using the portals in S is $d(u,v^{‘}\le d_l$.<br><strong>Lemm 9</strong> Denote the top entry in the priority queue $a_i$ as $(v,(u,S,d_l,d_u))$, then for any explored path p from $w_i$ in the queue $a_i$, the length of p, written as d(p), has $d(p)\le d_l$.<br><strong>Lemma 10</strong> let $g_1$ be a possible unexplored candidate answer rooted at a vertex in a partition h, with $h\in P_t$,    </p><script type="math/tex; mode=display">s(g_1)>\sum^m_{i=1}{d}^i_l\tag{3}</script><p><strong>Lemma 11</strong> Denote the bset possible unexplored candidate answer as $g_2$, which is rooted at a vertex in the partition h where $h\in P-P_t$, then    </p><script type="math/tex; mode=display">s(g_2)>\sum^m_{i=1}f(t_i)\hat{d}^i_l+(1-f(t_i))d^i_l, \tag{4}</script><p>where $f(t_i)=1\, if \, t_i\neq nil\, otherwise \, f(t_i)=0.$</p></blockquote><p><strong>The termination condition.</strong> 在未探索分区最有可能的答案是$s(g_1)$，如(3)式。在所有探索分区的最有可能的答案是$s(g_2)$，如(4)式。将得分升序排名第k的答案表示为g，则算法停止条件是$s(g)\le min (s(g_1),s(g_2))$.    </p><blockquote><p><strong>Theorem 2</strong> Summ finds the top-k answers A(q,k) for any top-k keyword search query q on an RDF graph.    </p></blockquote><h1 id="7-Accessing-data-and-update"><a href="#7-Accessing-data-and-update" class="headerlink" title="7 Accessing data and update"></a>7 Accessing data and update</h1><p>在对摘要图搜索完成后，我们需要从实体数据中检索出所选择分区，一个常用的方法是将三元组按分区存储并编上分区的id，但这样更新比较麻烦，并需要独立的存储。我们将RDF数据存储在RDF中，并通过构建的SPARQL查询动态的检索出该分区的数据。    </p><blockquote><p><strong>Theorem 3</strong> Homomorphism Throrem [1]. Let $q$ and $q^{‘}$ be relational queries over the same data D. Then $q^{‘}(D)\subseteq q(D)$ iff there exists a homomorphism mapping $f: q\rightarrow q^{‘}$.</p></blockquote><p>因为$c\rightarrow h_t \rightarrow h$因此用c作为SPARQL查询的pattern并结合Theorem 3可以抽取h。<br>两个关键问题：</p><ul><li>从$h_t$的集合到c通常有多对一的映射，使得若用c为query pattern会导致a low selectivity. 为解决此问题，我们在query pattern中从目标分区到相应变量间绑定了常量。</li><li>在构建S的过程中，并不保存每个c，而是当c是s的子树时将c插入到$s\in S$中。为了从s中构建SPARQL，首先找到根节点，然后拓展到叶子。</li></ul><h1 id="8-Experiments"><a href="#8-Experiments" class="headerlink" title="8 Experiments"></a>8 Experiments</h1><p><strong>Datasets</strong><br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig14-15.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h1&gt;&lt;p&gt;目前关键词搜索的两种方法：一、依赖建立距离矩阵来剪枝搜索空间，二、为RDF图建立摘要。本文指
      
    
    </summary>
    
      <category term="论文笔记" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="RDF" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/RDF/"/>
    
      <category term="2017年8月" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/2017%E5%B9%B48%E6%9C%88/"/>
    
      <category term="Keyword" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/Keyword/"/>
    
  </entry>
  
  <entry>
    <title>《RDF Keyword-based Query Technology Meets a Real-World Dataset》——论文笔记</title>
    <link href="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/08/15/test/"/>
    <id>https://github.com/LiuKaixin/LiuKaixin.github.io/2017/08/15/test/</id>
    <published>2017-08-15T08:12:00.000Z</published>
    <updated>2017-09-27T08:18:19.146Z</updated>
    
    <content type="html"><![CDATA[<p><strong>nucleus</strong></p><h1 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h1><p>本文介绍了一个工业项目，其通过将RDF技术和关键词搜索结合，开发出一种便于利用碳氢化合物对大型数据库进行数据访问的工具。该工具的特色是通过RDF schema和RDF数据，无需用户介入将关键词转化为SPARQL查询。工具还提供了一系列接口，如specify keywords, as well as filters and unit measures, and presents the results with the help of a table and a graph方便用户使用。</p><h1 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1. INTRODUCTION"></a>1. INTRODUCTION</h1><p>首先分析现有的网络上的关键词搜索技术，总结其成功的原因：</p><ol><li>简单易用的用户接口 </li><li>有效的文档检索机制</li><li>符合用户期望的排序算法</li></ol><p>对比来看，数据库管理系统提供了复杂的查询语言，一些数据库应用虽然创建了用户接口，让用户填一些空进行查询，隐藏查询语言的复杂性，但并不友好。我们提供关键词搜索接口，通过把关键词转换为查询语言，将用户从精准填空中解放出来。</p><p>关于关系型数据库的关键词查询出现了一段时间，现在也出现了关于RDF数据上的关键词查询。RDF不区分数据和元数据，因此关键词可能和类的名字、属性的描述或者数据的值匹配。RDF管理系统有时和提供推理层会以surpass/relational 视图对RDF数据产生推导数据，因此关键词也可能匹配推导数据。</p><p>本文贡献：</p><ul><li>定义RDF数据上关键词查询的答案。</li><li>通过利用RDF的schema和RDF数据集将关键词查询转换为SPARQL查询。</li><li>通过自动补全功能和filter、 unit measures的帮助允许用户精确关键字。</li><li>进行实验验证了工具的性能。</li></ul><h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h1><p><strong>Keyword-based query processing. </strong> 分为以下几类：</p><ul><li>schema-based：使用conceptual schema编译查询。</li><li>graph-based：直接在图上操作。</li><li>parttern-based：从RDF数据中挖掘pattern替代conceptual schema。</li><li>fully automatic：在关键词查询时无需依靠用户干预。</li></ul><p>BANKS and <a href="http://blog.csdn.net/u013319237/article/details/76050381" target="_blank" rel="external">BLINKS</a>是早期的graph-based工具。schema-based工具基于candidate networks （CNs）探索外键将关键词转化为SQL。例子有：DISCOVER，DBXplorer。</p><p>SPARK是早期的pattern-based RDF graph-based tool。[21]提出想法：利用类的层级从原始图中生成summary graphs，[26]负责实现。[24]挖掘tree pattern。[27]提出挖掘等价的structure patterns to summarize 知识图。[7]基于张量计算对RDF关键词查询。</p><p>QUICK[25]是一个RDF schema-based tool，需要用户介入。</p><p>本文的工具是schema-based并且fully automatic。从早期的graph-based工具中借鉴了生成由RDF schema引发的图的斯坦纳树来减少equijoins的想法。我们引入了新概念<em>nucleus</em>，其包含一个类，一个属性列表，一个属性值列表。nucleus 一定程度上和tuple相似。然后Steiner tree把那些包含关键词的nucleus连接起来。</p><p>和QUICK比较相似，但我们的RDF数据有rich schema并且低歧义，所以我们是全自动的转换。</p><p><strong>Triplification of the relational database. </strong>因为关系数据库经常是normalized不可直接映射到RDF，我们首先创造了定义了unnormalized关系视图，然后利用R2RML映射。<br>设计良好RDF schema帮助了关键词到SPARQL的转化，首先，RDF数据集具有已知模式的假设不应被视为缺点。实际上，大部分的LOD数据集确实有一个已知的模式（词汇或本体）[17]。此外，在像我们这样的企业环境中，RDF数据集通常是关系数据库的三元组化。第二，即使不能改变（关系或RDF）模式，也可以添加一个在视图的帮助下定义的概念层，这些概念层隐藏规范化，在关系情况下，或设计不当的RDF模式，这两种情况都会导致处理基于关键字的查询时的歧义。</p><p><strong>Benchmarks. </strong>他人所用的数据集及查询。</p><h1 id="3-BASIC-DEFINITIONS"><a href="#3-BASIC-DEFINITIONS" class="headerlink" title="3. BASIC DEFINITIONS"></a>3. BASIC DEFINITIONS</h1><h2 id="3-1-RDF-Essentials"><a href="#3-1-RDF-Essentials" class="headerlink" title="3.1 RDF Essentials"></a>3.1 RDF Essentials</h2><p>IRI(Internationalized Resource Identifier)：表示一个资源。<br>literal：一个基础值，如字符串，数字等<br>blank node：local identifier，可以被新的IRI替代。</p><p>本文中<strong>IRI</strong>代表所有的IRI的集合，<strong>L</strong>代表所有的literal的集合。</p><p>(s,p,o): s-IRI/ a blank node. p-IRI, o-IRI,a blank node or a literal.</p><p>RDF 三元组和RDF图等价。</p><p>RDF Schema 不提供实际的应用程序专用的类和属性，而是提供了描述应用程序专用的类和属性的框架。<br>RDF Schema 中的类与面向对象编程语言中的类非常相似。这就使得资源能够作为类的实例和类的子类来被定义。<br>介绍了<a href="https://www.w3.org/TR/rdf-schema/#ch_domain" target="_blank" rel="external">RDF Schema 及其一系列属性</a></p><p>An RDF schema is a set S of RDF triples that use the RDF-S vocabulary to declare classes, properties, property domains and ranges, and sub-class and sub-property axioms.</p><p>A simple RDF schema is a RDF schema that contains only class declarations, object and datatype property declarations and subclass axioms (and no sub-property axioms).</p><p>我们引入一个labelled graph, $D_s$ 被称为RDF schema diagram：</p><ul><li>the nodes of DS are the classes declared in S;</li><li>there is an edge from class c to class d labelled with subClassOf iff c is declared as a subclass of d in S, and there is an edge from class c to class d labelled with p iff p is declared in S as an object property with domain c and range d.</li></ul><p>RDF 数据集T follows RDF schema S的条件：</p><ol><li>$S\subseteq T$</li><li>T中的所有类和属性在S中都被定义</li><li>T中的三元组除了那些在S中的都满足S中声明的限制。</li></ol><h2 id="3-2-Keyword-Based-Queries"><a href="#3-2-Keyword-Based-Queries" class="headerlink" title="3.2 Keyword-Based Queries"></a>3.2 Keyword-Based Queries</h2><p>T: an RDF dataset.<br>$G_T$: $G_T$ is the corresponding RDF graph.<br>S: an RDF schema.<br>K: A keyword-based query—- a set of literals.<br>match $\mathbf L \times \mathbf L \rightarrow [0,1]$:literal之间的相似函数。<br>$\sigma \in (0,1]$: similarity threshold.<br>MM[K,S]:metadata matches between K and metadata descriptions of the classes and properties in S.    </p><script type="math/tex; mode=display">MM[K,T]=\{ (k,(r,p,v)) \in K\times T/ (r,p,v)\in S \wedge match(k,v)\le \sigma\}</script><p>VM[K,T]: property value matches between K and property values of T.    </p><script type="math/tex; mode=display">VM[K,T]=\{ (k,(r,p,v)) \in K\times T/ (r,p,v)\notin S \wedge match(k,v)\le \sigma\}</script><p>$M[K,T]=MM[K,T]\cup VM[K,T]$: matches between K and T.</p><img src="http://ouqbyuben.bkt.clouddn.com/images/EDBT_2017/keywords_matched.png"><p>答案的顺序：Given a directed graph G, let |G| denote the number of nodes and edges of G and #c(G) denote the number of connected components of G, when the direction of the edges of G is disregarded. We define a partial order “&lt;” for graphs such that, given two graphs G and G’,    </p><script type="math/tex; mode=display">G<G^{'} iff (\#c(G)+|G|)<(\#c(G^{'})+|G^{'}|) \,or\, (\#c(G)+|G|)=(\#c(G^{'})+|G^{'}|)\, and\, \#c(G)<\#c(G^{'})</script><img src="http://ouqbyuben.bkt.clouddn.com/images/EDBT_2017/fig1.jpg"><h1 id="4-TRANSLATION-OF-KEYWORD-QUERIES-TO-SPARQL-QUERIES"><a href="#4-TRANSLATION-OF-KEYWORD-QUERIES-TO-SPARQL-QUERIES" class="headerlink" title="4. TRANSLATION OF KEYWORD QUERIES TO SPARQL QUERIES"></a>4. TRANSLATION OF KEYWORD QUERIES TO SPARQL QUERIES</h1><h2 id="4-1-Overview-of-the-Translation-Algorithm"><a href="#4-1-Overview-of-the-Translation-Algorithm" class="headerlink" title="4.1 Overview of the Translation Algorithm"></a>4.1 Overview of the Translation Algorithm</h2><p>转化算法接受关键词查询K，RDF数据集T，输出一个SPARQL查询。<br>$G_T$: RDF graph。<br>$D_S$: RDF schema diagram。</p><p>Given a set of metadata matches MM[K,T] and a set of property value matches VM[K,T], we define two functions that group all keywords that match the same class or property:<br><img src="http://ouqbyuben.bkt.clouddn.com/images/EDBT_2017/4.1.jpg"><br><img src="http://ouqbyuben.bkt.clouddn.com/images/EDBT_2017/4.1nucleus.jpg"></p><p>N covers the set of keywords $K_n=K_0\cup K_1\cup…\cup K_m\cup K_{m+1}\cup …\cup K_{m+n}$<br>Given a set of nucleuses $\mathbf N =\{N_1,…,N_m\}$, we also say that <strong>N</strong> covers $K_{N1}\cup …\cup K_{Nm}$.<br>$\mathbf{N_C}$ : the set of classes of the nucleuses in <strong>N</strong>.</p><p>算法共有两个启发式：scoring and minimization。    </p><p>scoring：尝试捕捉用户意图，将关键词列表转换成查询。</p><ul><li>consider how good a match is, say “city” matches “Cities” better than “Sin City”.</li><li>assigns a higher score to metadata matches.</li><li>assigns a higher score to nucleuses that cover a larger number of keywords.</li></ul><p>对于nucleus N=(C,PL,PVL)：<br>$score(N)=(\alpha s_C+\beta s_p+(1-\alpha -\beta)s_V$<br>$s_C=meta_sim((K_0,c))$<br>$s_P=\sum_{(K_i,p_i)\in PL}meta \_ sim((K_i,p_i))$<br>$s_V=\sum_{(K_j,p_j)\in PVL}value \_ sim((K_j,p_j))$    </p><p>minimization：尝试生成minimal 答案，共两步。</p><ol><li>实现一个贪婪算法，对由最高分值的nucleuses排序，生成nucleus集合<strong>N</strong>。<ul><li>N covers a large subset of K</li><li>All nodes in $\mathbf{N_C}$ are in the same connected component of $D_S$<br>如果只由N中的nucleus产生答案，查询的得到的connected components可能和$N_C$中的类一样多。</li></ul></li><li>使用$D_S$中的一些边连接$C_N$中的classes强制一个答案只有一个connected component。这和产生以$N_C$中类为节点的斯坦纳树ST等价。然后，该算法使用ST的边来产生SPARQL查询Q的子句，使得Q的任何答案确实具有单个连接的分量。</li></ol><img src="http://ouqbyuben.bkt.clouddn.com/images/EDBT_2017/fig2.jpg">        <p>上图是算法的详细介绍，共有六步：</p><ol><li>去除K中stop words，对剩下部分与T进行匹配，得到MM[K,T]和VM[K,T]。第一步建立了辅助表加速了匹配过程。<ul><li>ClassTable：为S中的类存储IRI，label,description and other property values。</li><li>PropertyTable：存储属性元数据。</li><li>JoinTable：存储S中domains和ranges。</li><li>ValueTable：存储T中distinct property value pair.</li></ul></li><li>使用MM[K,T]和VM[K,T]计算得到a set M of nucleuses.</li><li>为M中的每个nucleus计算得分。</li><li>对应minimization启发式的第一步。把M中最大的核$N_0$从M中取出，放入N。$H_0$为$N_0$的RDF schema上的连通分量。从M中取出所有类不属于$H_0$的核。（为了保证第五步的正确性。）</li><li>实现minimization启发式的第二步。计算覆盖了$N_C$的最小斯坦纳树ST的分时。图中没有写出的详细步骤：首先计算a new labelled directed graph $G_N$ 。其点来自$N_C$，边来自RDF schema diagram $D_S$。然后为$G_N$计算一个最小的有向的spanning tree TN。如果不存在，则计算无向图TN。TN通过将其边替换为$D_S$中对应的路径，得到覆盖$N_C$中节点的$D_S$的斯坦纳树ST。</li><li>合成查询Q使得：<ul><li>Q返回T的子集。</li><li>Q的WHERE子句包含与N中的核的属性值对的元素相对应的过滤器。</li><li>Q的WHERE子句包含与ST中边缘相对应的equijoin子句。</li></ul></li></ol><p>使用引理证明算法的正确性：</p><blockquote><p><strong>Lemma</strong>: Let T be an RDF dataset, S be the RDF schema of T and K be a keyword-based query. Let Q be the SPARQL query the translation algorithm outputs for K,T and S. Then, any result of Q is an answer for K over T with a single connected component.</p></blockquote><h2 id="4-2-An-Example-the-Translation-Process"><a href="#4-2-An-Example-the-Translation-Process" class="headerlink" title="4.2 An Example the Translation Process"></a>4.2 An Example the Translation Process</h2><p>本节阐述算法如何为关键词查询K合成SPARQL查询。<br>流程和上一小节一致，不过举了个例子进行详细说明，此处略。</p><h2 id="4-3-User-Interface"><a href="#4-3-User-Interface" class="headerlink" title="4.3 User Interface"></a>4.3 User Interface</h2><ol><li>提供自动补全功能，基于之前的关键词，RDF schema字典和资源标识符的标签。如fig3a</li><li>利用斯坦纳树和表来展现结果，用户可以选择添加表中的属性。如fig3b，fig3c。</li><li>对比较符号如“&lt;”或预留单词“between”，可以生成简单的过滤器。<img src="http://ouqbyuben.bkt.clouddn.com/images/EDBT_2017/fig3.jpg"><h1 id="5-EXPERIMENTS"><a href="#5-EXPERIMENTS" class="headerlink" title="5. EXPERIMENTS"></a>5. EXPERIMENTS</h1><h2 id="5-1-Experimetn-setup"><a href="#5-1-Experimetn-setup" class="headerlink" title="5.1 Experimetn setup"></a>5.1 Experimetn setup</h2>电脑配置及运行环境~<h2 id="5-2-Experments-with-the-Industrial-Dataset"><a href="#5-2-Experments-with-the-Industrial-Dataset" class="headerlink" title="5.2 Experments with the Industrial Dataset"></a>5.2 Experments with the Industrial Dataset</h2>数据一开始被存储在传统的关系型数据库中，对于metadata matches十分有帮助。我们发现需要得到额外的元数据，如表中那些列是键，那些包含对象的扩展名等，这些对于关键词匹配和如何向用户展现对象等十分重要。操作流程如下：        <ol><li>在关系数据库这边，我们定义了一些列视图来denormalize表。</li><li>创建了一个XML文档对RDF schema中所有别的类和属性进行定义。</li><li>利用该XML文档构建了一个模型生成R2RML声明，帮助关系数据映射到三元组，以及生成4.1节中的辅助表。</li></ol></li></ol><p>（然后贴出部分RFD schema的图，并进行解释）</p><p>数据集属性较多（558个），关于属性的值大部分都是文字，适合关键词查询。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/EDBT_2017/table1.jpg"><br><img src="http://ouqbyuben.bkt.clouddn.com/images/EDBT_2017/table2.jpg"></p><h2 id="5-3-Experiments-with-Mondial-and-IMDb"><a href="#5-3-Experiments-with-Mondial-and-IMDb" class="headerlink" title="5.3 Experiments with Mondial and IMDb"></a>5.3 Experiments with Mondial and IMDb</h2><p>M:32/50<br>IMDb:36/50<br>然后说了一堆， 这个是缺乏关键词语义，关键词描述不准确云云。。</p><h1 id="6-CONCLUSIONS"><a href="#6-CONCLUSIONS" class="headerlink" title="6. CONCLUSIONS"></a>6. CONCLUSIONS</h1><p>总结了一堆功能，这是一个产品的说明并不像一篇科研论文，最后也是强调鲁棒性。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;nucleus&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;ABSTRACT&quot;&gt;&lt;a href=&quot;#ABSTRACT&quot; class=&quot;headerlink&quot; title=&quot;ABSTRACT&quot;&gt;&lt;/a&gt;ABSTRACT&lt;/h1&gt;&lt;p&gt;本文介绍了一个工业项目，其通
      
    
    </summary>
    
      <category term="论文笔记" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="keyword" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/keyword/"/>
    
      <category term="RDF" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/RDF/"/>
    
      <category term="SPARQL" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/SPARQL/"/>
    
      <category term="2017年8月" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/2017%E5%B9%B48%E6%9C%88/"/>
    
  </entry>
  
</feed>
