<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三省</title>
  
  <subtitle>吾日三省吾身</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/LiuKaixin/LiuKaixin.github.io/"/>
  <updated>2017-09-27T08:31:50.024Z</updated>
  <id>https://github.com/LiuKaixin/LiuKaixin.github.io/</id>
  
  <author>
    <name>刘凯鑫</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Top-k Exploration of Query Candidates for Efficient Keyword Search on Graph-Shaped (RDF) Data》——读书笔记</title>
    <link href="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/09/25/%E3%80%8ATop-k-Exploration-of-Query-Candidates-for-Efficient-Keyword-Search-on-Graph-Shaped-RDF-Data%E3%80%8B%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/LiuKaixin/LiuKaixin.github.io/2017/09/25/《Top-k-Exploration-of-Query-Candidates-for-Efficient-Keyword-Search-on-Graph-Shaped-RDF-Data》——读书笔记/</id>
    <published>2017-09-25T01:55:00.000Z</published>
    <updated>2017-09-27T08:31:50.024Z</updated>
    
    <content type="html"><![CDATA[<p><em>首先，初步确定一下本周的规划，今明两天读本篇论文，以及回顾之前的论文（按照师兄说的方式进行泛读），然后周三周四学习斯坦福的课程。周五将没有整理的论文整理完全，周六日搞定本篇和上篇论文。</em></p><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>从关键词中计算出queries之后，让用户选择合适的，然后送入数据库引擎进行查询。另外对于queries的计算，提出了找top-k子图的新型算法。</p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>提出关键词这样的搜索一直以来都是研究的重点。<br>Labelled query model：不需要用户对结构有任何的了解，只是单纯的将关键词和“labels”联系起来。<br>现在关键词搜索的主要思路：将关键词映射到data elements（很多使用精确匹配），搜索连接关键词的elements的子图（如Blinks中的distinct root assumption），基于得分函数（被提出了很多，从路径长度到IR中的复杂度量）输出top-k个子图（需要计算每个选项的上限和下限）。任务可分为四个：</p><ol><li>keyword mapping.</li><li>graph exploration.</li><li>scoring.</li><li>top-k computation.<br>本方法结合了语法和语义相似度，因此IR概念支持模糊匹配。本文贡献如下：</li></ol><ul><li><strong>Keyword Search through Query Computation </strong> 将关键词转化为结构化查询的元素（而不是答案的一部分），让用户选top-k个查询中的一个（而不是直接把top-k个答案给出）。</li><li><strong>Algorithms for Subgraph Exploration</strong> 当前的方法通常将关键词映射到节点，算法计算出树形的答案。但关键词也可能映射到边，所以答案结构也不一定是树。</li><li><strong>Efficient and Complete Top-k through Graph Summarization</strong> 很难簿记计算top-k所需的信息，现在的方法不能确保结果是真正的top-k。因此我们引入了复杂的数据结构保存所有候选的得分。为了效率，利用摘要图进行剪枝。<h1 id="2-Problem-Definition"><a href="#2-Problem-Definition" class="headerlink" title="2. Problem Definition"></a>2. Problem Definition</h1><strong>Data</strong><img src="http://ouqbyuben.bkt.clouddn.com/images/Top-k%20Exploration%20of%20Query%20Candidates%20for%20Efficient%20Keyword%20Search%20on%20Graph-Shaped%20%28RDF%29%20Data/Definition1.png"><strong>Queries</strong><br>用户的查询$Q_U$就是关键词集合，系统的查询$Q_S$是conjunctive queries.<img src="http://ouqbyuben.bkt.clouddn.com/images/Top-k%20Exploration%20of%20Query%20Candidates%20for%20Efficient%20Keyword%20Search%20on%20Graph-Shaped%20%28RDF%29%20Data/Definition2.png"><strong>Answers</strong><br>就是把查询中的distinguished variables 替换成子图中的节点。<img src="http://ouqbyuben.bkt.clouddn.com/images/Top-k%20Exploration%20of%20Query%20Candidates%20for%20Efficient%20Keyword%20Search%20on%20Graph-Shaped%20%28RDF%29%20Data/Definition3.png"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;首先，初步确定一下本周的规划，今明两天读本篇论文，以及回顾之前的论文（按照师兄说的方式进行泛读），然后周三周四学习斯坦福的课程。周五将没有整理的论文整理完全，周六日搞定本篇和上篇论文。&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abs
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《Answering top-K query combined keywords and structural queries on RDF graphs》——读书笔记</title>
    <link href="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/09/04/%E3%80%8AAnswering-top-K-query-combined-keywords-and-structural-queries-on-RDF-graphs%E3%80%8B%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/LiuKaixin/LiuKaixin.github.io/2017/09/04/《Answering-top-K-query-combined-keywords-and-structural-queries-on-RDF-graphs》——读书笔记/</id>
    <published>2017-09-04T12:36:00.000Z</published>
    <updated>2017-09-27T08:18:19.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h1><p>虽然SPARQL是RDF图上优越的查询语言，但一些查询意图仍无法使用SPARQL句法表达。关键词搜索虽然能够直观表示信息的需求，但表达准确度较低。为了综合两者的优点，提出了混合查询SK query，并使用基于结构化索引的新型查询算法加速查询。为了更进一步提高SK查询的效率还使用了基于距离的优化技术。</p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h1><p>目前RDF图十分流行，图1是Yago知识图谱的一个例子。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig1.png"><br>SPARQL基于子图匹配，是查询RDF数据的标准方法。但是由于用户不了解RDF的schema，所以查询的实体和谓词并不能和数据库中対映。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig2-3.png"><br>关键词查询是说明信息需求更直观的方法，但也常得到一些无意义的答案。<br>因此本文结合两者的优点提出SK query，其结果是最接近所有关键词的k个SPARQL结果。我们假设关系的强度依赖于路径长度，另外不同的谓词也应该有不同的权重。<br>该问题的另一个挑战是搜索效率，穷举法的流程如下：    </p><ol><li>用现有技术找出所有匹配的子图。</li><li>计算匹配子图和包含关键词的点间的最短路径。</li><li>找到路径最短的作为答案。</li></ol><p>但该方法太低效，我们为SPARQL查询Q设计了一个下限以尽早结束搜索，另外为结构化剪枝提出一个星型索引。提出一个基于距离的优化加速最短路径距离的计算——选择一些中心点，并使最短路径树以这些点为根；如果搜索到了中心点p，则可以使用根在p的最短路径减少搜索空间。<br>本文贡献：</p><ol><li>提出一个新的查询模式——SK query，结合了SPARQL和关键词，并提供了解决方法。</li><li>提出星型索引并实现最短路径树（基于距离的优化）以减少搜索空间和提高查询性能。</li><li>实验。</li></ol><h1 id="2-Background"><a href="#2-Background" class="headerlink" title="2. Background"></a>2. Background</h1><h2 id="2-1-Preliminaries"><a href="#2-1-Preliminaries" class="headerlink" title="2.1 Preliminaries"></a>2.1 Preliminaries</h2><blockquote><p><strong>Definition 2.1. </strong> An RDF data graph G is denoted as &lt; V(G), E(G), L&gt;, where (1) $V(G)= V_L \cup V_E \cup V_C$ is the set of vertices in RDF graph G ($V_L,\, V_E,\, V_C$ denote literal, entity and class vertices); (2) E(G) is the set of edges in G; and (3) L is a finite set of edge labels, i.e. predicates.<br><strong>Definition 2.2. </strong> An SK query is a pair &lt; Q,q&gt;, where Q is a SPARQL query graph, and q is a set of keywords ${w_1,w_2,…,w_n}$.</p></blockquote><p>对于SK query &lt; Q,q&gt;，查询结果是$&lt; M,{ v_1,v_2,…,v_n} >$, 其中M是Q的子图匹配，$v_i$是包含关键词$w_i$的literal vertex。</p><blockquote><p><strong>Definition 2.3.</strong> Given a result $r=&lt; M,{v_1,v_2,…,v_n}&gt;$, the cost of r is defined as follows:    </p><p><script type="math/tex">Cost(r) =Cost_{content}(r)+Cost_{structure}(r)</script>.<br><strong>Definition 2.4.</strong> Given a result $r=&lt; M,{v<em>1,v_2,…,v_n}&gt;$, the content cost of r is defined as follows:<br>$Cost</em>{content}(r)=\sum^{i=n}_{i=1}C(v_i,w_i)$,<br>where $C(v_i,w_i)$ is the matching cost between $v_i$ and keyword $w_i$.</p></blockquote><p>结构成本只考虑SPARQL查询中的变量——理由: 用户更感兴趣。（我感觉这并不科研）</p><blockquote><p><strong>Definition 2.5.</strong> Given a result $r=&lt; M,{v<em>1,v_2,…,v_n}&gt;$, the distance between match M and vertex $v_i$ is defined as follows:<br>$d(M,v_i)=MIN</em>{v\in M}{d(v,v<em>i)}$<br>其中v是M中和SPARQL查询中某个变量相关的点$d(v,v_i)$是v和G中$v_i$的最短距离。结果r的结构成本：<br>$Cost</em>{content}(r)=\sum^{i=n}_{i=1}C(v_i,w_i)$</p></blockquote><p>(<strong>Problem Definition</strong>) Given an SK query &lt;Q,q&gt; and parameter k, our problem is to find the k results that have the k-smallest costs.</p><h2 id="2-2-Predicate-salience"><a href="#2-2-Predicate-salience" class="headerlink" title="2.2 Predicate salience"></a>2.2 Predicate salience</h2><p>本文使用最短路径距离评估关系强度。一般的最短路径距离不区分谓词，把”type”、”label”等和普通谓词同等看待不合理。因此引入了predicate salience：    <script type="math/tex">ps(p)=\frac{|V(p)|}{|V(G)|}</script></p><h1 id="3-Overview"><a href="#3-Overview" class="headerlink" title="3. Overview"></a>3. Overview</h1><img src="http://ouqbyuben.bkt.clouddn.com/images/Answering%20top-K%20query%20combined%20keywords%20and%20structural%20queries%20on%20RDF%20graphs/fig5.png"><p><strong>Keyword Mapping.</strong> 离线时，为每个关键词建立倒排列表。在线时，根据倒排列表获取关键词对应的节点。对于关键词节点，在给定查询上的常用度量是TF/IDF成本。参考文献中有很多成本函数，我们选择其中一种计算包含关键字的节点的成本。<br>本文中主要关心如何找到SPARQL的匹配以及和关键词之间的关系。我们使用现有的IR引擎分析给定的关键词，并执行不精确匹配得到一些语法或语义相似的元素。<br><strong>Candidate Generation. </strong>如果找到能到达所有关键词的节点，则需要使用子图同态检查SPARQL的子图匹配是否包含该点。此步采用“filter-and-refine”策略，首先找到一些没有在任何Q的子图匹配中出现的dummy节点，如果搜索到dummy节点则不执行子图同态。<br>本文提出一种frequent star pattern-based structural index。基于该索引可以为SPARQL查询的变量提供候选列表。<br><strong>Top-k Results Computation. </strong>基于图搜索，循环地计算关键词节点与邻居的距离，找到一个能达到所有关键词的节点，如果不是dummy vertex，则使用SPARQL matching算法。</p><h1 id="4-Candidate-generation-based-on-the-structural-index"><a href="#4-Candidate-generation-based-on-the-structural-index" class="headerlink" title="4. Candidate generation based on the structural index"></a>4. Candidate generation based on the structural index</h1><h2 id="4-1-Structural-index"><a href="#4-1-Structural-index" class="headerlink" title="4.1 Structural index"></a>4.1 Structural index</h2><p>本节提出一个frequent star pattern-based index。从G中挖掘出一些常见的星型模式，并为每个星型模式建立一个节点的倒排列表。选择星型的原因是在SPARQL查询常包含星型子查询。星型模式的挖掘使用现有的sequential pattern挖掘算法，如PrefixSpan。<br>我们不能为每个星型模式建立目录，因此我们我们定义了discriminative ratio。</p><blockquote><p><strong>Definition 4.1. </strong>Given a star S, its discriminative ratio is defined as follows:<br>$\gamma (S)=\frac{|L(S)|}{|\cap_{S^{‘}\subset S} \,\,L(S^{‘})|}$</p></blockquote><p>如果$\gamma (S)$越大，则说明如果保存S的子集作为目录元素的话，就没必要保存S作为目录元素。因此设定$\gamma (S)\le \gamma_{max}$。但对于只有一条边的星型查询，我们始终将其放入目录中。</p><blockquote><p><strong>Theorem 4.1. </strong> Let F denote all selected index elements (i.e., frequent star patterns). Given a SPARQL query Q, a vertex v in graph G can be pruned (there exists no subgraph match of Q containing v) if the following equation holds.<br>$v\notin \cup_{S\in F \land S \in Q}L(S)$,</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ABSTRACT&quot;&gt;&lt;a href=&quot;#ABSTRACT&quot; class=&quot;headerlink&quot; title=&quot;ABSTRACT&quot;&gt;&lt;/a&gt;ABSTRACT&lt;/h1&gt;&lt;p&gt;虽然SPARQL是RDF图上优越的查询语言，但一些查询意图仍无法使用SPARQL句法表达。关
      
    
    </summary>
    
      <category term="论文笔记" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="2017年9月" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/2017%E5%B9%B49%E6%9C%88/"/>
    
  </entry>
  
  <entry>
    <title>《Keyword Search in Graphs: Finding r-cliques》——读书笔记</title>
    <link href="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/08/24/%E3%80%8AKeyword-Search-in-Graphs-Finding-r-cliques%E3%80%8B%E2%80%94%E2%80%94%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/LiuKaixin/LiuKaixin.github.io/2017/08/24/《Keyword-Search-in-Graphs-Finding-r-cliques》——读书笔记/</id>
    <published>2017-08-24T03:18:00.000Z</published>
    <updated>2017-09-27T08:18:19.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ABSTRCT"><a href="#ABSTRCT" class="headerlink" title="ABSTRCT"></a>ABSTRCT</h1><p>图上的关键词搜索是找到一个包含所有关键词的子结构，之前的工作都是找最小连通图（connected minimal trees），而现在发现找子图比找子树对用户来说更有用。子树中的关键词节点（content nodes）彼此间可能并不紧连，另外，在找子树时会遍历整个图而不仅是关键词节点。<br>An r-clique is a group of content nodes that cover all the input keywords and the distance between each two nodes is less than or equal to r.</p><h1 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1. INTRODUCTION"></a>1. INTRODUCTION</h1><blockquote><p><a href="http://www.morganclaypool.com/doi/pdf/10.2200/S00231ED1V01Y200912DTM001" target="_blank" rel="external">keyword search in databases.</a>是联通子树（这是一本书，我没看。。。）。李国良的文章<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.184.8489&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">Ease: Efficient and adaptive keyword search on unstructured, semi-structured and structured data</a> 的答案是半径不大于r的斯坦纳树。</p></blockquote><p>以前基于树或图的方法存在的问题：</p><ol><li>一些关键词节点（content nodes）相距太远。</li><li>对所有的节点遍历，时间和空间复杂度都很高。</li></ol><p>使用r-cliques的优点：</p><ol><li>所有关键词节点相距很近。</li><li>无需遍历所有节点。</li></ol><p>举例说明：<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Keyword%20search%20in%20graphs%20Finding%20r-cliques/fig1.png"><br><img src="http://ouqbyuben.bkt.clouddn.com/images/Keyword%20search%20in%20graphs%20Finding%20r-cliques/fig2.png"><br>关键词：James, John, Jack。 r=10。<br>图2(a)中的答案比图2(c)中的更加合理，因为三个点在同一个组织。另外三边之和也是图2(a)更小。但是对于用文献<a href="http://dl.acm.org/citation.cfm?id=1547515" target="_blank" rel="external">13</a>生成的两者的斯坦纳树，结果相反。</p><p>本文贡献：</p><ol><li>提出一个新的图关键词搜索的模型。</li><li>证明找到有最小权重的r-clique是NP-hard问题。</li><li>基于Branch和Bound的算法找到所有的r-cliques。</li><li>提出一个找2个近似度的r-cliques的近似算法，能在多项式时间内以升序找到所有的r-clique。</li><li>为了找到某个r-clique中的节点的关系，提出在图中找连接r-clique中节点的斯坦纳树。</li></ol><blockquote><p><a href="http://dl.acm.org/citation.cfm?id=2749447" target="_blank" rel="external">Exact Top-k Nearest Keyword Search in Large Networks</a><br>There are other keyword search problems that are of some different characteristics. The general idea of keyword search is to find a subgraph in a given graph that contains the query keywords.<br>The subgraph can be of the form of a tree in some cases. </p><ul><li>BANKS in [5] converts a relational database into a graph and answers to keyword queries are directed subtrees in the graph. Given a directed graph, the keyword search in [16] returns top ranked subtrees in the graph that cover the query keywords. </li><li>Blinks [18] also considers directed graph and given a keyword query, an answer is a subtree in the graph that covers the keywords and the root of the subtree can reach all the keywords. Top-k results are top k subtrees with different roots. </li><li>The graph type of r-clique is introduced in [21] as the form of expected answers. An r-clique is a set of vertices in the given graph which covers the given query keywords and the distance between any pair of the vertices in this set is no longer than r. Both exact and approximate algorithms have been proposed in [21]. Querying the neighbors of a vertex in a compressed social network is considered in [24]</li></ul><p><a href="http://www.sciencedirect.com/science/article/pii/S0306457314000727#b0155" target="_blank" rel="external">Efficient processing of keyword queries over graph databases for finding effective answers</a>一篇较新的关于树形的文章。</p><ul><li>the minimal Steiner tree semantics.将答案树的权重定义为边的和，所以问题就转化成optimal group Steiner tree problem.有些人用启发式的规则得到l倍近似的结果（l是关键词数目）；有人用dp…但这些方法并不能有效的在大图上得出top-k Steiner tree-stuctured answers.</li><li>distinct root semantics.答案树的权重为根节点到关键词节点的最短路径之和，每个根节点只有权重最小的答案树被作为候选。因此，对于n个点的图，至多有n个答案，所以比斯坦纳树更高效（这里没懂）。</li><li>之前的工作限制着包含一个关键词的节点个数有且只有一个，本文中答案树包含一个关键词的节点可能有多个。</li></ul><p><a href="http://dl.acm.org/citation.cfm?id=3022863" target="_blank" rel="external">Survey on Keyword Search over XML Documents</a>  该文第3章提出对于XML关键词搜索基于图的方法。</p><ol><li>Subtree based Semantics for <strong>Directed</strong> Graphs.<ul><li>the minimal Steiner tree semantics. <a href="http://delivery.acm.org/10.1145/1380000/1376708/p927-golenberg.pdf?ip=166.111.134.52&amp;id=1376708&amp;acc=ACTIVE%20SERVICE&amp;key=BF85BBA5741FDC6E%2E587F3204F5B62A59%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&amp;CFID=882572412&amp;CFTOKEN=29985573&amp;__acm__=1505267509_337f555665e22704b8e4b8b45b2f64af" target="_blank" rel="external">Keyword proximity search in complex data graphs.</a></li><li>the distinct root semantics. <a href="http://dl.acm.org/citation.cfm?id=1247516" target="_blank" rel="external">BLINKS: ranked keyword searches on graphs</a></li></ul></li><li>Subgraph based Semantics for <strong>Undirected</strong> Graphs. (方法的优劣暂且不论，其应用在无向图，但RDF是有向图)<ul><li>r-radius semantics. <a href="http://dl.acm.org/citation.cfm?id=1376706" target="_blank" rel="external">EASE: Efficient and adaptive keyword search on unstructured, semi-structured and structured data.</a>（2008）</li><li>r-clique semantics. <a href="http://dl.acm.org/citation.cfm?id=2021025" target="_blank" rel="external">Keyword search in graphs: finding r-cliques</a>（2011）</li><li>minimum cost connected tree. <a href="http://ieeexplore.ieee.org/abstract/document/4221732/" target="_blank" rel="external">Finding top-k min-cost connected trees in database.</a>（2007）</li></ul></li><li>Bi-directed Tree based Semantics for Directed Graphs<br>BANKS和<a href="http://dl.acm.org/citation.cfm?id=1083652" target="_blank" rel="external">Bidirectional expansion for keyword search on graph databases</a>（2005）返回有前向边或后向边的子树。<a href="http://dl.acm.org/citation.cfm?id=1142377" target="_blank" rel="external">Finding and approximating top-k answers in keyword proximity search</a>返回混合了前向边和后向边的子树。（2006）</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ABSTRCT&quot;&gt;&lt;a href=&quot;#ABSTRCT&quot; class=&quot;headerlink&quot; title=&quot;ABSTRCT&quot;&gt;&lt;/a&gt;ABSTRCT&lt;/h1&gt;&lt;p&gt;图上的关键词搜索是找到一个包含所有关键词的子结构，之前的工作都是找最小连通图（connected m
      
    
    </summary>
    
      <category term="论文笔记" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Keyword" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/Keyword/"/>
    
      <category term="2017年9月" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/2017%E5%B9%B49%E6%9C%88/"/>
    
  </entry>
  
  <entry>
    <title>《Natural Language Question Answering over RDF ——  A Graph Data Driven Approach》——论文笔记</title>
    <link href="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/08/24/%E3%80%8ANatural-Language-Question-Answering-over-RDF-%E2%80%94%E2%80%94-A-Graph-Data-Driven-Approach%E3%80%8B%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/LiuKaixin/LiuKaixin.github.io/2017/08/24/《Natural-Language-Question-Answering-over-RDF-——-A-Graph-Data-Driven-Approach》——论文笔记/</id>
    <published>2017-08-24T03:15:00.000Z</published>
    <updated>2017-09-27T08:18:19.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h1><p>RDF Q/A允许用户对RDF知识库用自然语言提问。为回答该提问，需要两步：理解问题和执行查询。现有工作大都集中在解决自然语言的歧义，通常做法是the joint disambiguation，使搜索空间指数增长。本文从图数据驱动的角度解决该问题，提出使用语义查询图为自然语言的查询意图建模，将问题归约成子图匹配问题。更重要的是，我们通过查询的匹配情况，解决自然语言问题的多义性。实验结果验证算法。</p><h1 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1. INTRODUCTION"></a>1. INTRODUCTION</h1><p>背景：用户需从知识库中获取知识，RDF格式成为标准，SPARQL查询对用户不友好，需要RDF Q/A系统。</p><h1 id="1-1-Motivation"><a href="#1-1-Motivation" class="headerlink" title="1.1 Motivation"></a>1.1 Motivation</h1><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/fig1.png"><p>现在RDF Q/A系统主要分两个阶段：question understanding和query evaluation。第一阶段把自然语言问题N转化成SPARQLs，这也是目前大部分工作的研究重点。第二阶段执行第一阶段得到的SPARQls。如图1所示，(a)是RDF数据集，(b)是目前解决方法的两个步骤，可以看到由于多义性，有些短语对应多个实体。如果同时考虑这些短语则增加了响应时间。<br>本文并不在第一阶段解决多义性问题，而是放到第二阶段，能够避免问题理解阶段的高昂的消歧处理，从而加速整个系统。本方法中最关键的问题在于如何定义RDF图G中的子图和自然语言问题N的匹配，以及如何找到匹配。</p><h2 id="1-2-Our-Approach"><a href="#1-2-Our-Approach" class="headerlink" title="1.2 Our Approach"></a>1.2 Our Approach</h2><p>虽然本方法仍有“question understanding”和“query evaluation”，但并不与现在的SPARQL generation-and-evaluation相同，本方法是graph data-driven，其大概的框架如图1(c)。<br>在question understanding阶段，我们把问题iN翻译为semantic query graph $Q^{S}$。该步允许多义。<br>在query evaluation阶段，我们在图G上找$Q^{S}$的匹配的子图。我们基于语义相似性定义了匹配的分数。<br>将消歧放在query evaluation阶段不仅提高了精度也加速了整个查询应答时间。<br>贡献：</p><ol><li>为问题提出了系统的框架。并从graph data-driven的角度，将消歧放在了query evaluation阶段。</li><li>离线处理：提出图挖掘算法，将短语匹配到top-k个可能的谓词，形成paraphrase dictionary D。</li><li>在线处理：两个阶段，首先将问题N转换为semantic query graph $Q^{S}$，然后把RDF Q/A归约成$Q^{S}$在图G上的子图匹配问题。在找到匹配时解决了多义问题，如果没有匹配发现则消歧的花费就被节省了。</li><li>实验</li></ol><h1 id="2-FRAMEWORK"><a href="#2-FRAMEWORK" class="headerlink" title="2. FRAMEWORK"></a>2. FRAMEWORK</h1><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/table1.png"><p>本问题有两个关键的挑战，一是如何以结构化的方式表示问题N中的查询意图。二是如何处理问题N中的短语的多义性。<br>为解决第一个挑战，我们从N中抽出semantic relations，并基于此建立了semantic query graph $Q^{S}$为问题N中的问题意图建模。</p><blockquote><p>Definition 1. <strong>(Semantic Relation).</strong> A semantic relation is a triple <rel, arg1,="" arg2="">, where rel is a relation phrase in the paraphrase dictionary D, arg1 and arg2 are the two argument phrases.<br>Definition 2. <strong>(Semantic Query Graph)</strong> A semantic query graph is denoted as $Q^S$, in which each vertex $v_i$ is associated with an argument and each edge $\bar{v_iv_j}$ is associated with a relation phrase, $1\le i,j\le |V(Q^{S})|$.    </rel,></p></blockquote><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/fig2.png"><p>针对第二个挑战，我们提出了数据驱动的方法：对于N中一个短语到实体的映射，如果能找到包含该实体的子图且匹配N中的查询意图，那该映射是正确的；否则是错误的。</p><h2 id="2-1-Offline"><a href="#2-1-Offline" class="headerlink" title="2.1 Offline"></a>2.1 Offline</h2><p>建立了paraphrase dictionary D——记录语义相等的关系短语和谓词。一些现有的系统如Patty和ReVerb还未每个关系短语提供了其支持的实体对，如表2。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/table2.png"><br>方法思路：对每个关系短语$rel_i$，$Sup(rel_i)$表示一系列该谓词支持的实体对。我们假设这些实体对也出现在RDF图中。频繁出现的谓词连接$Sup(rel_i)$中的实体对和关系短语$rel_i$等价。基于该想法我们提出一个找语义相等的关系短语和谓词的图挖掘算法。</p><h2 id="2-2-Online"><a href="#2-2-Online" class="headerlink" title="2.2 Online"></a>2.2 Online</h2><p>1) <em>Question Understanding. </em>目的在于为问题N构建一个语义查询图$Q^{S}$。首先用Stanford Parser得到N的依赖树Y，然后基于paraphrase dictionary D抽取Y中的语义关系。基本的思路是找到一个Y的包含rel的所有词的最小子树。该子树被称为Y中的rel的一个嵌入，并且基于一些语言规则我们得到有联系的两个参数，形成$&lt; rel,arg1,arg2 &gt;$，最后连接这些关系得到查询图$Q^{S}$。<br>2) <em> Query Evaluation. </em>找到与$Q^{S}$匹配的子图。匹配按照子图同态定义。    </p><p>首先，$Q^{S}$的点，被映射到RDF图中的一些实体或类，并赋予一个置信度，保存在有序列表$C<em>{v_i}$。关系短语$rel</em>{\overline{v<em>iv_j}}$被映射到候选谓词的列表$C</em>{\overline{v_iv_j}}$中。列表以置信度排序。本步中并没有解决多义问题。<br>其次，</p><blockquote><p>Definition 3.<strong>(Match)</strong> Consider a semantic query graph $Q^{S}$ with n vertices ${v<em>1,…,v_n}$. Each vertex $v_i$ has a condidate list $C</em>{v<em>i},i=1,…,n.$ Each edge $\overline{v_iv_j}$ also has a candidate list of $C</em>{\overline{v_iv_j}}, where $1\le i\ne j\le n.$ A subgraph M containing n vertices ${u_1,…,u_n}$ in RDF graph G is a match of $Q^{S}$ if and only if the following conditions hold: </p><ol><li>if $v<em>i$ is mapping to an entity $u_i$, i=1,…,n, $u_i$ must be in list $C</em>{v_i}$;</li><li>if $v<em>i$ is mapping to a class $c_i$, i=1,…,n, $u_i$ is an entity whose type is $c_i$ (i.e., there is a triple &lt;$u_i$ rdf:type $c_i$&gt; in RDF graph) and $c_i$ must be in $C</em>{v_i}$;</li><li>$\forall \overline{v<em>iv_j}\in Q^S; \, \overrightarrow{u_iu_j}\in G \lor  \overrightarrow{u_ju_i}\in G$. Furthermore, the predicate $P</em>{ij}$ associated with $\overrightarrow{u<em>iu_j}$ (or $\overrightarrow{u_ju_i}$ is in $C</em>{\overline{v_iv_j}},\, 1\le i,j\le n$.</li></ol></blockquote><p>每个和$Q^S$匹配的子图都有一个得分，由边和点的概率决定。我们的目标是找到top-k个匹配的子图，在4.2.2节中解决。</p><h1 id="3-OFFLINE"><a href="#3-OFFLINE" class="headerlink" title="3. OFFLINE"></a>3. OFFLINE</h1><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/fig3.png"><p>语义关系抽取依赖于词典D，图3是词典的一个示例。本文并不讨论如何抽取短语及其对应的实体对，假设已经给定。<br>在offline中的任务是找到语义相等的关系短语和RDF中的相应谓词，即构建如图3的词典D。假设已有词典$T={rel<em>1,…,rel_n}$，每个$rel_i$都是一个关系短语，并有一个出现在RDF图中的实体对集合，即$Sup(rel_i)={(v^1_i,V^{‘1}_i),…,(v^m_i,V^{‘m}_i),}$。对于每个$rel_i$目标是找到RDF图中的top-k个语义相等的谓词（路径）。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/fig4.png"><br>方法：给定一个关系短语$rel_i$及$Sup(rel_i)={(v^1_i,V^{‘1}_i),…,(v^m_i,V^{‘m}_i),}$，对$(v^j_i,V^{‘j}_i),j = 1,…,m$，我们在RDF图中找到两点间的简单路径：$Path(v^j_i,V^{‘j}_i)$，如图4。则$PS(rel_i)=\bigcup</em>{j=1,…,m}Path(v^j_i,V^{‘j}_i)$.    为了效率，我们设定了路径的阈值，然后使用双向的BFS搜索找到$Path(v^j_i,V^{‘j}_i)$。<br>但是这样的方法会带来噪音，解决方法：采用了tf-idf度量。</p><blockquote><p>Definition 4. Given a predicate path L, the tf-value of L in $PS(rel_i)$ is defined as follows:    </p><script type="math/tex; mode=display">tf(L,PS(rel_i))=|\{Path(v^j_i,V^{'j}_i)| L\in Path(v^j_i,V^{'j}_i)\}|</script><p>The idf-value of L over the whole relation phrase dictionary $T={rel_1,…,rel_n}$ is defined as follows:</p><script type="math/tex; mode=display">idf(L,T)=log \frac{|T|}{|\{rel_i\in T|L \in PS(rel_i)\}|+1}</script><p>The tf-idf value of L is defined as follows:</p><script type="math/tex; mode=display">tf-idf(L,PS(rel_i),T)=tf(L,PS(rel_i))\times idf(L,T)</script></blockquote><p>关系短语和谓词（路径）的置信度定义为：</p><script type="math/tex; mode=display">\delta (rel,L)=tf-idf(L,PS(rel_i),T) \tag{1}</script><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/alg1.png"><p>算法1展示了为每个关系短语找top-k谓词路径的细节。注意tf-idf is a probability value to evaluate the mapping (from relation phrase to predicate/predicate paths) confidence.<br>维护D只需要为新引入的谓词重新挖掘映射，或删除被移除数据集的谓词的映射。</p><blockquote><p>Theorem 1. The time complexity of Algorithm 1 is $O(|T|\times |V|^2\times d^2)$, where |T| is the number of relation phrases in T, |V| is the number of vertices in RDF graph G, and d is the maximal vertex degree.</p></blockquote><h1 id="4-ONLINE"><a href="#4-ONLINE" class="headerlink" title="4. ONLINE"></a>4. ONLINE</h1><h2 id="4-1-Question-Understanding"><a href="#4-1-Question-Understanding" class="headerlink" title="4.1 Question Understanding"></a>4.1 Question Understanding</h2><p>本节讨论如何识别问题N中的语义关系，并基于关系建立语义查询图$Q^S$代表N中的查询意图。<br>为抽取句子关系短语，建立依赖树。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/fig5.png"><br>图5展示了问题N的依赖树表示为Y。</p><blockquote><p>Definition 5. Let us consider a dependency tree Y of a natural language question N and a relation phrase rel. We say that rel occurs in Y if and only if there exists a connected subtree y (of Y) satisfying the following conditions:</p><ol><li>Each node in y contains one word in rel and y includes all words in rel.</li><li>We cannot find a subtree $y^{‘}$ of Y, where $y^{‘}$ also satisfies the first condition and y is a subtree of $y^{‘}$.<br>In this case, y is an embedding of relation phrase rel in Y.</li></ol></blockquote><p>给定问题N的依赖树Y和关系短语词典$T={rel_1,…,rel_n}$，我们需要T中那个关系短语在Y中出现。</p><h3 id="4-1-1-Finding-Relation-Phrase-Embeddings"><a href="#4-1-1-Finding-Relation-Phrase-Embeddings" class="headerlink" title="4.1.1 Finding Relation Phrase Embeddings"></a>4.1.1 Finding Relation Phrase Embeddings</h3><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/alg2.png"><blockquote><p>Theorem 2. The time complexity of Algorithm 2 is $O(|Y|^2)$.</p></blockquote><h3 id="4-1-2-Finding-Associated-Arguments"><a href="#4-1-2-Finding-Associated-Arguments" class="headerlink" title="4.1.2 Finding Associated Arguments"></a>4.1.2 Finding Associated Arguments</h3><p>通常参数的识别依赖subject-relations、object-like relations，如下：</p><ol><li>subject-like relations: sbj, nsubj, nsubjpass, csubj, csubj-pass, xsubj, poss;</li><li>object-like relations: obj,pobj, dobj, iobj</li></ol><p>假设关于短语rel的嵌入子树为y。通过检查y中的每个节点w及其子节点是否出现以上的subject-like（object-like）关系，出现则把子节点加入到arg1（arg2）。<br>如果arg1/arg2仍是空，我们有以下启发式规则：</p><ul><li>Rule 1: Extend the embedding t with some light words, such as prepositions, auxiliaries. Recognize subject/object-like relations for the newly added tree node.</li><li>Rule 2: If the root node of t has subject/object-like relations with its parent node in Y, add the root node to arg1.</li><li>Rule 3: if the parent of the root node of t has subject-like relations with its child, add the child to arg1.</li><li>Rule 4: If one of arg1/arg2 is empty, add the nearest wh-word (such as what, who and which) or the first noun phrase in t to arg1/arg2.     </li></ul><p>如果arg1/arg2仍然是空，则放弃关系短语rel。</p><h3 id="4-1-3-Building-Semantic-Query-Graph"><a href="#4-1-3-Building-Semantic-Query-Graph" class="headerlink" title="4.1.3 Building Semantic Query Graph"></a>4.1.3 Building Semantic Query Graph</h3><p>把语义关系<rel,arg1,arg2>表示为边，如果两个关系的参数相同，则边相连。</rel,arg1,arg2></p><h2 id="4-2-Query-Evaluation"><a href="#4-2-Query-Evaluation" class="headerlink" title="4.2 Query Evaluation"></a>4.2 Query Evaluation</h2><h3 id="4-2-1-Phrases-Mapping"><a href="#4-2-1-Phrases-Mapping" class="headerlink" title="4.2.1 Phrases Mapping"></a>4.2.1 Phrases Mapping</h3><p>讨论如何将关系短语和参数映射到候选的谓词（路径）和实体。<br><strong>Mapping edges of $Q^S$.</strong> $Q^S$中边$\overline{v<em>iv_j}$对应关系短语$rel</em>{\overline{v<em>iv_j}}$。按照paraphrase dictionary D，$rel</em>{\overline{v<em>iv_j}}$映射到列表$C</em>{\overline{v_iv_j}}$，列表中是谓词P或谓词路径L。$\delta(rel,L)$置信度。<br><strong>Mapping Vertices of $Q^S$.</strong>  $Q^S$中点v对应参数arg。如果arg是wh-word，则它可映射到RDF中所有实体和类，否则返回一个对应的实体或类的列表。本文使用现成的工具DBpedia Lookup。$\delta(arg,c)$置信度。<br><strong>Graph Data-driven Disambiguation.</strong> graph data-driven solution.</p><h3 id="4-2-2-Finding-top-k-Subgraph-Matches"><a href="#4-2-2-Finding-top-k-Subgraph-Matches" class="headerlink" title="4.2.2 Finding top-k Subgraph Matches"></a>4.2.2 Finding top-k Subgraph Matches</h3><blockquote><p>Definition 6. Given a semantic query graph $Q^S$ with n vertices ${v_1,…,v_n)}$, a subgraph M containing n vertices ${u_1,…,u_n}$ in RDF graph G is a match of $Q^S$. The match score is defined as follows:    </p><script type="math/tex; mode=display">Score(M)=log( \prod_{v_i\in V(Q^S)} \delta (arg_i,u_i) \times \prod_{\overline{v_iv_j}\in E(Q^S)} \delta (rel_{\overline{v_iv_j}},P_{ij})  )\\=\sum_{v_i\in V(Q^S)} log( \delta (arg_i,u_i))+\sum_{\overline{v_iv_j}\in E(Q^S)} log( \delta (rel_{\overline{v_iv_j}},P_{ij})  ) \tag{2}</script><p>where $arg<em>i$ is the argument of vertex $v_i$, and $u_i$ is an entity or a class in RDF graph G, and $rel</em>{\overline{v<em>iv_j}}$ is the relation phrase of edge $\overline{v_iv_j}$ and $P</em>{ij}$ is a predicate of edge $\overrightarrow{u_iu_j}$ or $\overrightarrow{u_ju_i}$</p></blockquote><p>给定语义查询图$Q^S$，我们目标是找到$Q^S$的所有匹配中分数top-k的。这是个NP-hard问题。</p><blockquote><p>Lemma 1. Finding Top-1 subgraph match of $Q^S$ over RDF graph G is an NP-hard problem.<br>Lemma 2. Finding Top-k subgraph match of $Q^S$ over RDF graph G is at least as hard as finding Top-1 subgraph match of $Q^S$ over G.<br>Theorem 3.  Finding Top-k subgraph match of $Q^S$ over RDF graph G is an NP-hard problem.</p></blockquote><p>因为他是NP-hard问题，所以我们设计启发式规则减少搜索空间。第一个利用neighborhood-based pruning减少$C<em>{v_i}$和$C</em>{\overline{v_iv_j}}$。第二个是基于top-k匹配的分阈值及早停止搜索。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/alg3.png"></p><h1 id="5-TIME-COMPLEXITY-ANLYSIS"><a href="#5-TIME-COMPLEXITY-ANLYSIS" class="headerlink" title="5. TIME COMPLEXITY ANLYSIS"></a>5. TIME COMPLEXITY ANLYSIS</h1><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/table3.png"><h1 id="6-EXPERIMENTS"><a href="#6-EXPERIMENTS" class="headerlink" title="6. EXPERIMENTS"></a>6. EXPERIMENTS</h1><img src="http://ouqbyuben.bkt.clouddn.com/images/Natural%20Language%20Question%20Answering%20over%20RDF%20——%20%20A%20Graph%20Data%20Driven%20Approach/table4-5.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ABSTRACT&quot;&gt;&lt;a href=&quot;#ABSTRACT&quot; class=&quot;headerlink&quot; title=&quot;ABSTRACT&quot;&gt;&lt;/a&gt;ABSTRACT&lt;/h1&gt;&lt;p&gt;RDF Q/A允许用户对RDF知识库用自然语言提问。为回答该提问，需要两步：理解问题和执行查
      
    
    </summary>
    
      <category term="论文笔记" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="RDF" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/RDF/"/>
    
      <category term="2017年8月" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/2017%E5%B9%B48%E6%9C%88/"/>
    
      <category term="QA" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/QA/"/>
    
  </entry>
  
  <entry>
    <title>《Scalable Keyword Search on Large RDF Data》——论文笔记</title>
    <link href="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/08/20/%E3%80%8AScalable-Keyword-Search-on-Large-RDF-Data%E3%80%8B%E2%80%94%E2%80%94%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/LiuKaixin/LiuKaixin.github.io/2017/08/20/《Scalable-Keyword-Search-on-Large-RDF-Data》——论文笔记/</id>
    <published>2017-08-20T05:10:00.000Z</published>
    <updated>2017-09-27T08:18:19.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>目前关键词搜索的两种方法：一、依赖建立距离矩阵来剪枝搜索空间，二、为RDF图建立摘要。本文指出现有技术面对真实数据集时的不足，并且提出一个新的摘要算法，能够更有效的剪枝并得到正确的答案。</p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><ul><li>动机：RDF数据急速增长。关键词搜索对大规模数据十分有用，目前对于RDF数据的解决方法的局限：<ul><li>返回不正确的答案。</li><li>难以处理大规模RDF数据。    </li></ul></li><li>目标：设计一个能处理大规模RDF数据集的scalable and exact soluton。</li><li>贡献：<ul><li>identify and address limitations in the existing methods for keyword search in RDF data. 并基于后向搜索提出一个正确的baseline解法。</li><li>develop efficient algorithms to summarize the structure of RDF data, based on the types in RDF graohs. 和之前的方法相比more scalable剪枝也更有意义，并且得到的摘要是轻量级的而且可更新。</li><li>experiments on both benchmark and large real RDF datasets.</li></ul></li></ul><h1 id="2-Preliminaries"><a href="#2-Preliminaries" class="headerlink" title="2 Preliminaries"></a>2 Preliminaries</h1><p>将RDF数据集看做RDF图G=(V,E)其中</p><ul><li>$V={V_E,V_T,V_W}$<ul><li>$V_E$: the set of entity vertices.</li><li>$V_T$: the set of type vertices.    </li><li>$V_W$: the set of keyword vertices.    </li></ul></li><li>$E={E_R,E_A,E_T}$<ul><li>$E_R$: the set of entity-entity edges.</li><li>$E_A$: the set of entity-keyword edges.</li><li>$E_T$: the set of entity-type edges.</li></ul></li></ul><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig1.png">    <p>图1中主要结构被entity-entity edge即$E_R$捕获，因此将entity vertex和关于他的type vertex和keyword vertex看做一个点，我们得到RDF图G的压缩视图，表示为$G_c={V^{‘}_E,E_R}$。其中$|V^{‘}_E| \equiv |V_E|$，$v^{‘}\in V^{‘}_E$包含$v\in V_E$和与之联系的类型和关键词节点。</p><h2 id="2-1-Problem-statement"><a href="#2-1-Problem-statement" class="headerlink" title="2.1 Problem statement"></a>2.1 Problem statement</h2><p>关键词查询问题即RDF图中寻找包含所有关键词的子图。<br>为便于表示，假设每个节点只包含一个关键词。（但对于包含多个和不包含的也能处理）<br>对在$G={V,E}$上的查询$q={w_1,w_2,…,w_m}$，点集${r,v_1,…,v_m}$在以下条件成立时被称为 qualified candidate:</p><ul><li>root answer node $r\in V$能够到达任一点$v_i\in V,\, i\in [1,m]$</li><li>$w(v_i)=w_i$</li></ul><p>A(q): the answer for q<br>C(q): the set of all qualified candidates in G with respect to q.    </p><script type="math/tex; mode=display">A(q)= arg min_{g\in C(q)}s(g), \, and \, s(g)=\sum_{r,v_i\in g, i=1..m}d(r,v_i)\tag{1}</script><p>其中$d(r,v_i)$是从r到$v_i$的距离（不考虑边方向）。</p><p>该定义还有一个top-k版本，其中对每个$g\in C(q)$的得分s(g)进行升序排列，得到前k个答案。</p><h1 id="3-Related-work"><a href="#3-Related-work" class="headerlink" title="3 Related work"></a>3 Related work</h1><p>许多技术假设图能够在内存中处理，如<a href="http://dl.acm.org/citation.cfm?id=1247516" target="_blank" rel="external">14</a> <a href="http://dl.acm.org/citation.cfm?id=1247516" target="_blank" rel="external">17</a>为所有的点对保存了距离矩阵。另外这些工作不考虑如何处理更新。本文中我们将后向搜索应用于大RDF图并经过严密的证明，不依赖于距离矩阵。<br>关于摘要大图来支持关键词搜索的技术来自于[9]，作者假设块之间的边是有权重的，块被当做supernode，块之间的边被当做superedges，它们组成摘要图。然后循环此过程。该方法针对通用图，并不能拓展到RDF图中。<br>[23]研究了RDF图上的关键词搜索，和本文一样，其调整了[14]中的问题定义。该方法从RDF数据集中摘要出schema，在schema中应用后巷搜索得到最有可能的关系，然后将关系转化为SPARQL中的pattern进行检索。<br>[23]中摘要算法的局限：将同一类型的所有实体归结到一个点，丢失了太多信息，以至于产生错误结果。另外该方法不支持更新。<br>[18]中通过对异质关系编码为图，支持结构化，半结构化和非结构化的关键词查询。同样的，他也需要距离矩阵。<br><a href="https://link.springer.com/chapter/10.1007/978-3-642-25073-6_13" target="_blank" rel="external">11</a> <a href="http://dl.acm.org/citation.cfm?id=1376708" target="_blank" rel="external">12</a>研究了排序函数。我们则是调整了RDF[23]和通用图[14]中的排序函数。</p><h1 id="4-The-Baseline-Method"><a href="#4-The-Baseline-Method" class="headerlink" title="4 The Baseline Method"></a>4 The Baseline Method</h1><p>baseline基于“backward search”的启发式。<br>“backward search”：图中对应关键词查询的所有节点同时开始，迭代地想邻居节点拓展，直到候选答案生成。<em>termination condition</em>用来判断搜索过程是否完成。<br>[23]中的termination condition是当m个节点第一次遇到节点r时返回答案并停止搜索，但该方法并不正确。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig5.png"><br><strong>Counter example. </strong>对于图a来说，第二轮迭代得到$g={r=v_4,v_1,v_2,v_6,v_7}\, \, s(g)=8$，但第四轮迭代中$g^{‘}={r=v_3,v_1,v_2,v_6,v_7}\, \, s(g^{‘})=6$。<br><strong>The correct termination.</strong> 如算法1.<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/alg1.png"><br><em>Data structure. </em><br>$q={w_1,…w_m}$: query<br> G={V,E}: a (condensed) RDF graph<br> $W_i$: vertices in V containing the keyword $w_i$<br> ${a_1,…a_m}$: m empty priority queues, one for each query keyword.<br> M: 集合中每个元素对应目前探索到的独一无二的node，记录他们能够到达那个关键词以及距离。对于fig5(a)，$M[v_3]={(v_1,1),(v_2,1),nil,(v_7,1)}$<br><em>The algorithm. </em>(图片中是不是line10,11写错了？）<br>第一轮迭代算是初始化$a_i$和M。$W_i$中每个v和其邻居u放入$a_i$中，并新建$M[u]$或更新$M[u]$的相应值。<br>第二轮迭代首先pop$a_i$的堆顶值，然后添加 $(v,p={v,…,u},d(p))}$中u的每个邻居$u^{‘}$。将 $(v,p={v,…,u^{‘}},d(p)+1)}$压入$a_i$然后更新$M[u^{‘}]$。<br>如果$M[u]$没有nil，则该条被标记为候选答案，u为候选根节点。将M[u]中的最短路径表示为g，我们有：</p><blockquote><p><strong>Lemma 1 </strong> $g={r=u,v<em>{l_1},…,v</em>{l<em>m}}$ is a condidate answer with $s(g)=\Sigma^m</em>{i=1}d(u,v_{l_i})$.</p></blockquote><p>两种情况：(i) an unseen vertex, i.e., $v\notin M$, will become the answer root(Lemma 2); (ii) a seen but not fully expanded vertex $v\in M$ will become the answer root(Lemma 3).<br>$V_t$: the set of vertices that are not fully explored.<br>$(v_1,p_1,d(p_1)),…(v_m,p_m,d(p_m))$: the top entries from $a_1…a_m$.</p><blockquote><p><strong>Lemma 2</strong> Denote the best possible candidate answer as $g<em>1$, and a vertex $v\notin M$ as the answer root of $g_1$. Then it must have $s(g_1)&gt;\Sigma^m</em>{i=1}d(p_i)$.<br><strong>Lemma 3</strong> Suppose the best possible candidate answer using such an $v(v\in M\, and \, v\in V_t)$ as the answer root is $g_2$ then    </p><script type="math/tex; mode=display">s(g_2)>\sum^m_{i=1}f(v_{b_i})d_i + (1-f(v_{b_i}))d(p_i) \tag{2}</script><p>where $f(v<em>{b_i})=1$ if $M[v][b_i]\neq nil$, and $f(v</em>{b_i})=0$ otherwise.</p></blockquote><p><strong>The termination condition.</strong> 对于情况(i)，我们简单的让$s(g<em>1)=\Sigma ^m</em>{i=1}d(p_i)$;对于情况(ii)，we find a vertex with the smallest possible $s(g_2)$ value w.r.t. the RHS of (2), and simply denote its best possible score as $s(g_2)$.<br>Denote the kth smallest candidate answer identified in the algorithm as g, our search can safely terminate when $s(g)\le min(s(g_1),s(g_2))=s(g_2)$. </p><blockquote><p><strong>Theorem 1</strong> The Backward method finds the top-k answers A(q,k) for any top-k keyword query q on RDF graph.</p></blockquote><h1 id="5-Type-Based-Summarization"><a href="#5-Type-Based-Summarization" class="headerlink" title="5 Type-Based Summarization"></a>5 Type-Based Summarization</h1><p>Backward方法对大的RDF图不适用，因为Backward为完成搜索，会构建无数的搜索路径。为了减少Backward算法的输入规模，只在有希望的子图上应用。我们提出了一个type-based摘要方法，即先在摘要图上进行关键词搜索，剪枝掉大部分无用的结果，然后再应用Backward。<br><strong>The intuition.</strong> 首先对RDF图分区，被查询的关键词首先由分区连接。挑战在于如何对不会产生top-k跨区答案进行剪枝。要做到这个我们需要对跨越分区的后向搜索的路径距离进行校正。但维护所有路径的距离成本太高，因此我们提取一个可更新的摘要图，使得任何后向搜索可以被有效地估计。<br>The key observation: 紧邻的相同类型邻居节点一般共享相似的结构——和其他类型的节点的连接，如fig6。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig6.png"><br>我们基于以上观察构建一个typed-based summary。</p><h2 id="5-1-Outline-and-preliminaries"><a href="#5-1-Outline-and-preliminaries" class="headerlink" title="5.1 Outline and preliminaries"></a>5.1 Outline and preliminaries</h2><p>首先将RDF图划分为多个小的区，然后定义摘要了分区的type-baseed structures。摘要保存所有分区的不同结构。通常关键词搜索在两方面受益于摘要：    </p><ul><li>we can obtain the upper and lower bounds for the distance traversed in any backward expansion without constructing the actual path (Section 6).</li><li>we can efficiently retrieve every partition from the data by collaboratively using SPARQL query and any RDF store without explicity storing the partition (Section 15).</li></ul><p>两个定义：<br><strong>Homomorphism across partitions. </strong> 如图6(a)所示，邻近的类型节点是生成induced partitions的好的源头。图6(a)是图6(b)的子集。We consider discovering such embeddings between the induced partitions, so that one template can be reused to bookkeep multiple structures.    </p><blockquote><p><strong>Definition 1</strong> A graph homomorphism f from a graph $G={V,E}$ to a graph $G^{‘}={V^{‘},E^{‘}}$, writtern as $f: G\rightarrow G^{‘}$, is a mapping function $f: V\rightarrow V^{‘}$ such that(i) f(x)=x indicates that x and f(x) have the same type; (ii) $(u,v)\in E$ implies $(f(u),f(v)) \in E^{‘}$ and they have the same label. When such an f exists, we say G is homomorphic to $G^{‘}$.    </p></blockquote><p><strong>Cores for indeividual partitions.</strong> A <em>core</em> is a graph that is only homomorphic to itself, but not to any one of its proper subgraphs.<br><strong>Definition 2</strong> A core c of a graph G is a graph with the following properties: there exists a homomorphism from c to G; there exists a homomorphism from G to c; and c is minimal with these properties.<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig7.png">    </p><h2 id="5-2-Partition"><a href="#5-2-Partition" class="headerlink" title="5.2 Partition"></a>5.2 Partition</h2><p>摘要过程开始于将数据分成较小的，语义相似的，边不相交的子图。鉴于我们观察到相同类型的节点共享相似的类型邻居，我们基于类型用环绕相同类型节点的子图对G划分。算法使用RDF的condensed视图。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/alg2.png"><br>${T_1,…,T_n}$: n distinct number of types.<br>$V_i$vertices whose type is $T_i$.<br>h(v,$\alpha$)(the $\alpha$-neighborhood of v): the subgraph from G obtained by expanding v with $\alpha$ hops.    拓展时的边不在P中，且是有向图，所以h(v,$\alpha$)是v $\alpha$跳邻居节点的子集。<br>P：初始化为空，然后每个h(v,$\alpha$)都是一个新的划分。    </p><blockquote><p><strong>Lemma 4</strong> Partitions in P are edge disjoint and the union of all partitions in P cover the entire graph G.</p></blockquote><p>我们遍历类型的顺序不同可能会影响分区P的最终结果。但无论怎样，同种类型的节点总是基于其$\alpha$-neighborhoods生成一系列划分。如图8。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig8.png">    </p><h2 id="5-3-Summarization"><a href="#5-3-Summarization" class="headerlink" title="5.3 Summarization"></a>5.3 Summarization</h2><p>摘要算法从P的分区集合中识别出一系列templates。这些templates是partitions 的摘要。另外摘要算法保证P中的每个分区都与某个templates同态。该特性是的查询优化器：</p><ol><li>不用频繁访问RDF数据的前提下有效地在后向拓展时估计路径长度。</li><li>通过查询RDF数据来有效地重构感兴趣的分区，而不显式地存储和索引分区。</li></ol><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/alg3.png">    <p>给定一个分区P，算法3检索出所有的不同的结构并将其保存在S中。<br><strong>Improving efficiency and reducing |S|.</strong><br>算法3的两个问题：(1)在3,5,7行需要判断同态，这是NP-hard问题。(2) 尽量减少|S|的大小，以便能够放入内存中处理。<br>对$h(v,\alpha)$的边建立一个covering tree，即$h_t(v,\alpha)$。并用$h_t(v,\alpha)$代替$h(v,\alpha)$。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig9.png"><br><strong>Example 2. </strong>图9中，$h(v_1,2)$$中$v_4$节点在不同边中被访问了三次，所以有三个拷贝。<br>该方法的优点：</p><ul><li>降低S中不同结构的数量，如图9所示，两个在数据层面不同的结构，在类型层面共享一个结构。</li><li>对于通用图来说，检测子图同态十分耗时。但能在多项式时间内检测类型层面的结构。</li></ul><h2 id="5-4-Auxiliary-indexing-structures"><a href="#5-4-Auxiliary-indexing-structures" class="headerlink" title="5.4 Auxiliary indexing structures"></a>5.4 Auxiliary indexing structures</h2><p>为了帮助关键词搜索，我们维护了三个辅助列表。<br>a portal node：node that isincluded in more than one partitions. <em>portal index</em> for each partition $h(v,\alpha)$, 我们赋予其唯一id并和portal列表联系。<br>$\sigma (v_i)$: 表示$h_t(v,\alpha)$中的所有$v_i$。$\Sigma={\sigma (v_1),\sigma(v_2),…}$：表示一个分区中所有的一对多的映射。如图9中，$h(v_1,2)$$\Sigma \leftarrow {\sigma (v_4)={T_4}}$. <em>partition index</em>: to map the partition root v of $h(v,\alpha)$ to its $\Sigma$.<br><em>summary index</em>: 将partitions中的节点映射到S中的摘要节点。sid: S中的每个摘要的id，nid: S中每个节点的id。<br>为了获得每个$h_t(v,\alpha)$到S中的summary的映射，需要建立日志保存建立S时的发现的所有同态。等S建立完成后我们遍历日志找到所有从数据到summary的映射。过程如图10.<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig10.png">    </p><h1 id="6-Keyword-search-with-summary"><a href="#6-Keyword-search-with-summary" class="headerlink" title="6 Keyword search with summary"></a>6 Keyword search with summary</h1><p>搜索算法，摘要层和数据层的两级后向搜索。只有摘要层中被识别的connected partitions包含所有关键词，并且其分数在top-k，才会进入数据层执行后向搜索。路径长度计算是后向搜索和剪枝的核心，但摘要层并不能拿到准确的路径长度，因此首先展示如何估计路径长度，然后介绍算法。</p><h2 id="6-1-Bound-the-shortest-path-length"><a href="#6-1-Bound-the-shortest-path-length" class="headerlink" title="6.1 Bound the shortest path length"></a>6.1 Bound the shortest path length</h2><p>通过summary index，分区根节点v到分区内任一节点u的最短距离可计算，所以由三角形不等式得：$|d(v,v_1)-d(v,v_2)|\le d(v_1)-d(v_2)\le |d(v,v_1)+d(v,v_2)|$。另外，另一个下界可用根节点v所在分区的同态的摘要图得到，即Lemma 5：</p><blockquote><p><strong>Lemma 5</strong> Given two graphs g and h, if $f:g\rightarrow h$, then $\forall v_1,v_2\in g$ and their homomorphic mappings $f(v_1),f(v_2)\in h,\, d(v_1,v_2)\le d(f(v_1),f(v_2))$.</p></blockquote><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig11.jpg">    <p>如图11，从h到s没有直接的同态，因此不能直接应用Lemma 5。定义映射函数Join。输入：图g，${V^{‘}<em>{t_1},V^{‘}</em>{t<em>2},…}$。输出：新图$g^{‘}=Join(g(V,E),{V^{‘}</em>{t<em>1},V^{‘}</em>{t<em>2},…})$。其中$V^{‘}</em>{t_i}$中的点都属于类型$t_i$。函数流程：</p><ol><li>用g初始化$g^{‘}$；</li><li>将$g^{‘}$中的$V^{‘}<em>{t_i}$合并至类型为$t_i$的点$v^{‘}</em>{i}$，点集$V^{‘}<em>{t_i}$中的所有边也赋于$v^{‘}</em>{i}$；</li><li>对所有类型重复步骤2。</li></ol><p><strong>Example 3. </strong>以图9为例，$Join(h_t(v_1,2),{\Sigma(T_4)})$重建了$h(v_1,2)$，因此两者同态。另外，$Join(h_t(v_5,2),{\Sigma(T_4)})$没有重建$h(v_5,2)$，但等于$h(v_1,2)$也和$h(v_5,2)$同态。</p><blockquote><p><strong>Lemma 6</strong> For a partition h and its covering tree $h_t$, there is a homomorphism from h to $Join(h_t,\Sigma)$.<br><strong>Lemma 7</strong> For a partition h, its covering tree $h_t$ and its summary s that has $f_2:h_t\rightarrow s$, there is a homomorphism from $Join(h_t,\Sigma)$ to $Join(s,f_2(|Sigma))$.</p></blockquote><p>如图11b，由Lemmas 6,7和同态的可传递性，h is homomorphic to $Join(s,f_2(\Sigma))$。其中$f_2$是summary index的一部分，将数据中的节点映射到摘要中的节点。最后，给定h中任意两点，其最短路径可有Lemmas 5,6,7和最短路径算法在$Join(s,f_2(\Sigma))$中找到最短路的一个下限。实际应用中，我们从summary和三角不等式中找一个更高的下限。</p><h2 id="6-2-The-algorithm"><a href="#6-2-The-algorithm" class="headerlink" title="6.2 The algorithm"></a>6.2 The algorithm</h2><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/alg4.png">    <p><strong>Data structures. </strong><br>$q={w_1,…w_m}$: query<br> G={V,E}: a (condensed) RDF graph<br> $W_i$: vertices in V containing the keyword $w_i$<br> ${a_1,…a_m}$: m empty priority queues, one for each query keyword.<br> M: 集合中每个元素对应目前探索到的独一无二的node，记录他们能够到达那个关键词以及历经的分区。M中每个条目是四元组$(u,S,d_l,d_u)$。u是后向搜索中包含关键$w_i$的第一个节点。S存储搜索过程中路径的一系列partitions及其portal（exit node），因此S是(portal, partition root)的集合。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig12.png"><br><strong>The algorithm. </strong></p><ul><li><em>In the first iteration. </em>对于每个来自$W_i$的点u，我们从summary index对u所述的分区根节点v检索。并将检索结果插入M和$a_i$中。</li><li><em>In the j-th iteration.</em> 从所有的$a_i$中pop出最小的条，即$(v,(u,S,d_l,d_u))$(line 10). v是当前分区的根节点。S中最后的对是$(l,v_l)$：路径在$v_l$点离开根为$v_l$的分区并进入现分区。$\mathcal{L}={\mathcal{l}^{‘}_1,\mathcal{l}^{‘}_2,…}$表示根节点为v的分区的portals。对于每个$l^{‘}$按照6.1节的方法计算$d(l,l^{‘})$或$d(u,l^{‘})$的上下限。然后第14行更新，其中$v_r$是与$l^{‘}$相连的下一个分区的根节点。M只有在两种情况下停止更新：(i)S的路径产生了环。(ii)$d_l+d^{‘}_l$比当前第i个列表中第k大的上限还要大。    如果M[v]的所有条目非空，则以v为根节点的分区是候选答案。将m个关键词对应的列表组合起来就是联通子图。    然后我们拿到所选分区的实际数据（如何拿到在第7节），进行二级搜索。</li><li><em>Termination condition. </em>Lemma 8,9.    </li></ul><blockquote><p><strong>Lemma 8</strong> Denote an entry in the priority queue as $(v,(u,S,d_l,d_u))$, then for any $v^{‘}$ in the partition rooted at v and the length of any path starting from u and using the portals in S is $d(u,v^{‘}\le d_l$.<br><strong>Lemm 9</strong> Denote the top entry in the priority queue $a_i$ as $(v,(u,S,d_l,d_u))$, then for any explored path p from $w_i$ in the queue $a_i$, the length of p, written as d(p), has $d(p)\le d_l$.<br><strong>Lemma 10</strong> let $g_1$ be a possible unexplored candidate answer rooted at a vertex in a partition h, with $h\in P_t$,    </p><script type="math/tex; mode=display">s(g_1)>\sum^m_{i=1}{d}^i_l\tag{3}</script><p><strong>Lemma 11</strong> Denote the bset possible unexplored candidate answer as $g_2$, which is rooted at a vertex in the partition h where $h\in P-P_t$, then    </p><script type="math/tex; mode=display">s(g_2)>\sum^m_{i=1}f(t_i)\hat{d}^i_l+(1-f(t_i))d^i_l, \tag{4}</script><p>where $f(t_i)=1\, if \, t_i\neq nil\, otherwise \, f(t_i)=0.$</p></blockquote><p><strong>The termination condition.</strong> 在未探索分区最有可能的答案是$s(g_1)$，如(3)式。在所有探索分区的最有可能的答案是$s(g_2)$，如(4)式。将得分升序排名第k的答案表示为g，则算法停止条件是$s(g)\le min (s(g_1),s(g_2))$.    </p><blockquote><p><strong>Theorem 2</strong> Summ finds the top-k answers A(q,k) for any top-k keyword search query q on an RDF graph.    </p></blockquote><h1 id="7-Accessing-data-and-update"><a href="#7-Accessing-data-and-update" class="headerlink" title="7 Accessing data and update"></a>7 Accessing data and update</h1><p>在对摘要图搜索完成后，我们需要从实体数据中检索出所选择分区，一个常用的方法是将三元组按分区存储并编上分区的id，但这样更新比较麻烦，并需要独立的存储。我们将RDF数据存储在RDF中，并通过构建的SPARQL查询动态的检索出该分区的数据。    </p><blockquote><p><strong>Theorem 3</strong> Homomorphism Throrem [1]. Let $q$ and $q^{‘}$ be relational queries over the same data D. Then $q^{‘}(D)\subseteq q(D)$ iff there exists a homomorphism mapping $f: q\rightarrow q^{‘}$.</p></blockquote><p>因为$c\rightarrow h_t \rightarrow h$因此用c作为SPARQL查询的pattern并结合Theorem 3可以抽取h。<br>两个关键问题：</p><ul><li>从$h_t$的集合到c通常有多对一的映射，使得若用c为query pattern会导致a low selectivity. 为解决此问题，我们在query pattern中从目标分区到相应变量间绑定了常量。</li><li>在构建S的过程中，并不保存每个c，而是当c是s的子树时将c插入到$s\in S$中。为了从s中构建SPARQL，首先找到根节点，然后拓展到叶子。</li></ul><h1 id="8-Experiments"><a href="#8-Experiments" class="headerlink" title="8 Experiments"></a>8 Experiments</h1><p><strong>Datasets</strong><br><img src="http://ouqbyuben.bkt.clouddn.com/images/Scalable%20Keyword%20Search%20on%20Large%20RDF%20Data/fig14-15.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h1&gt;&lt;p&gt;目前关键词搜索的两种方法：一、依赖建立距离矩阵来剪枝搜索空间，二、为RDF图建立摘要。本文指
      
    
    </summary>
    
      <category term="论文笔记" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="RDF" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/RDF/"/>
    
      <category term="2017年8月" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/2017%E5%B9%B48%E6%9C%88/"/>
    
      <category term="Keyword" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/Keyword/"/>
    
  </entry>
  
  <entry>
    <title>《RDF Keyword-based Query Technology Meets a Real-World Dataset》——论文笔记</title>
    <link href="https://github.com/LiuKaixin/LiuKaixin.github.io/2017/08/15/test/"/>
    <id>https://github.com/LiuKaixin/LiuKaixin.github.io/2017/08/15/test/</id>
    <published>2017-08-15T08:12:00.000Z</published>
    <updated>2017-09-27T08:18:19.146Z</updated>
    
    <content type="html"><![CDATA[<p><strong>nucleus</strong></p><h1 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h1><p>本文介绍了一个工业项目，其通过将RDF技术和关键词搜索结合，开发出一种便于利用碳氢化合物对大型数据库进行数据访问的工具。该工具的特色是通过RDF schema和RDF数据，无需用户介入将关键词转化为SPARQL查询。工具还提供了一系列接口，如specify keywords, as well as filters and unit measures, and presents the results with the help of a table and a graph方便用户使用。</p><h1 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1. INTRODUCTION"></a>1. INTRODUCTION</h1><p>首先分析现有的网络上的关键词搜索技术，总结其成功的原因：</p><ol><li>简单易用的用户接口 </li><li>有效的文档检索机制</li><li>符合用户期望的排序算法</li></ol><p>对比来看，数据库管理系统提供了复杂的查询语言，一些数据库应用虽然创建了用户接口，让用户填一些空进行查询，隐藏查询语言的复杂性，但并不友好。我们提供关键词搜索接口，通过把关键词转换为查询语言，将用户从精准填空中解放出来。</p><p>关于关系型数据库的关键词查询出现了一段时间，现在也出现了关于RDF数据上的关键词查询。RDF不区分数据和元数据，因此关键词可能和类的名字、属性的描述或者数据的值匹配。RDF管理系统有时和提供推理层会以surpass/relational 视图对RDF数据产生推导数据，因此关键词也可能匹配推导数据。</p><p>本文贡献：</p><ul><li>定义RDF数据上关键词查询的答案。</li><li>通过利用RDF的schema和RDF数据集将关键词查询转换为SPARQL查询。</li><li>通过自动补全功能和filter、 unit measures的帮助允许用户精确关键字。</li><li>进行实验验证了工具的性能。</li></ul><h1 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2. Related Work"></a>2. Related Work</h1><p><strong>Keyword-based query processing. </strong> 分为以下几类：</p><ul><li>schema-based：使用conceptual schema编译查询。</li><li>graph-based：直接在图上操作。</li><li>parttern-based：从RDF数据中挖掘pattern替代conceptual schema。</li><li>fully automatic：在关键词查询时无需依靠用户干预。</li></ul><p>BANKS and <a href="http://blog.csdn.net/u013319237/article/details/76050381" target="_blank" rel="external">BLINKS</a>是早期的graph-based工具。schema-based工具基于candidate networks （CNs）探索外键将关键词转化为SQL。例子有：DISCOVER，DBXplorer。</p><p>SPARK是早期的pattern-based RDF graph-based tool。[21]提出想法：利用类的层级从原始图中生成summary graphs，[26]负责实现。[24]挖掘tree pattern。[27]提出挖掘等价的structure patterns to summarize 知识图。[7]基于张量计算对RDF关键词查询。</p><p>QUICK[25]是一个RDF schema-based tool，需要用户介入。</p><p>本文的工具是schema-based并且fully automatic。从早期的graph-based工具中借鉴了生成由RDF schema引发的图的斯坦纳树来减少equijoins的想法。我们引入了新概念<em>nucleus</em>，其包含一个类，一个属性列表，一个属性值列表。nucleus 一定程度上和tuple相似。然后Steiner tree把那些包含关键词的nucleus连接起来。</p><p>和QUICK比较相似，但我们的RDF数据有rich schema并且低歧义，所以我们是全自动的转换。</p><p><strong>Triplification of the relational database. </strong>因为关系数据库经常是normalized不可直接映射到RDF，我们首先创造了定义了unnormalized关系视图，然后利用R2RML映射。<br>设计良好RDF schema帮助了关键词到SPARQL的转化，首先，RDF数据集具有已知模式的假设不应被视为缺点。实际上，大部分的LOD数据集确实有一个已知的模式（词汇或本体）[17]。此外，在像我们这样的企业环境中，RDF数据集通常是关系数据库的三元组化。第二，即使不能改变（关系或RDF）模式，也可以添加一个在视图的帮助下定义的概念层，这些概念层隐藏规范化，在关系情况下，或设计不当的RDF模式，这两种情况都会导致处理基于关键字的查询时的歧义。</p><p><strong>Benchmarks. </strong>他人所用的数据集及查询。</p><h1 id="3-BASIC-DEFINITIONS"><a href="#3-BASIC-DEFINITIONS" class="headerlink" title="3. BASIC DEFINITIONS"></a>3. BASIC DEFINITIONS</h1><h2 id="3-1-RDF-Essentials"><a href="#3-1-RDF-Essentials" class="headerlink" title="3.1 RDF Essentials"></a>3.1 RDF Essentials</h2><p>IRI(Internationalized Resource Identifier)：表示一个资源。<br>literal：一个基础值，如字符串，数字等<br>blank node：local identifier，可以被新的IRI替代。</p><p>本文中<strong>IRI</strong>代表所有的IRI的集合，<strong>L</strong>代表所有的literal的集合。</p><p>(s,p,o): s-IRI/ a blank node. p-IRI, o-IRI,a blank node or a literal.</p><p>RDF 三元组和RDF图等价。</p><p>RDF Schema 不提供实际的应用程序专用的类和属性，而是提供了描述应用程序专用的类和属性的框架。<br>RDF Schema 中的类与面向对象编程语言中的类非常相似。这就使得资源能够作为类的实例和类的子类来被定义。<br>介绍了<a href="https://www.w3.org/TR/rdf-schema/#ch_domain" target="_blank" rel="external">RDF Schema 及其一系列属性</a></p><p>An RDF schema is a set S of RDF triples that use the RDF-S vocabulary to declare classes, properties, property domains and ranges, and sub-class and sub-property axioms.</p><p>A simple RDF schema is a RDF schema that contains only class declarations, object and datatype property declarations and subclass axioms (and no sub-property axioms).</p><p>我们引入一个labelled graph, $D_s$ 被称为RDF schema diagram：</p><ul><li>the nodes of DS are the classes declared in S;</li><li>there is an edge from class c to class d labelled with subClassOf iff c is declared as a subclass of d in S, and there is an edge from class c to class d labelled with p iff p is declared in S as an object property with domain c and range d.</li></ul><p>RDF 数据集T follows RDF schema S的条件：</p><ol><li>$S\subseteq T$</li><li>T中的所有类和属性在S中都被定义</li><li>T中的三元组除了那些在S中的都满足S中声明的限制。</li></ol><h2 id="3-2-Keyword-Based-Queries"><a href="#3-2-Keyword-Based-Queries" class="headerlink" title="3.2 Keyword-Based Queries"></a>3.2 Keyword-Based Queries</h2><p>T: an RDF dataset.<br>$G_T$: $G_T$ is the corresponding RDF graph.<br>S: an RDF schema.<br>K: A keyword-based query—- a set of literals.<br>match $\mathbf L \times \mathbf L \rightarrow [0,1]$:literal之间的相似函数。<br>$\sigma \in (0,1]$: similarity threshold.<br>MM[K,S]:metadata matches between K and metadata descriptions of the classes and properties in S.    </p><script type="math/tex; mode=display">MM[K,T]=\{ (k,(r,p,v)) \in K\times T/ (r,p,v)\in S \wedge match(k,v)\le \sigma\}</script><p>VM[K,T]: property value matches between K and property values of T.    </p><script type="math/tex; mode=display">VM[K,T]=\{ (k,(r,p,v)) \in K\times T/ (r,p,v)\notin S \wedge match(k,v)\le \sigma\}</script><p>$M[K,T]=MM[K,T]\cup VM[K,T]$: matches between K and T.</p><img src="http://ouqbyuben.bkt.clouddn.com/images/EDBT_2017/keywords_matched.png"><p>答案的顺序：Given a directed graph G, let |G| denote the number of nodes and edges of G and #c(G) denote the number of connected components of G, when the direction of the edges of G is disregarded. We define a partial order “&lt;” for graphs such that, given two graphs G and G’,    </p><script type="math/tex; mode=display">G<G^{'} iff (\#c(G)+|G|)<(\#c(G^{'})+|G^{'}|) \,or\, (\#c(G)+|G|)=(\#c(G^{'})+|G^{'}|)\, and\, \#c(G)<\#c(G^{'})</script><img src="http://ouqbyuben.bkt.clouddn.com/images/EDBT_2017/fig1.jpg"><h1 id="4-TRANSLATION-OF-KEYWORD-QUERIES-TO-SPARQL-QUERIES"><a href="#4-TRANSLATION-OF-KEYWORD-QUERIES-TO-SPARQL-QUERIES" class="headerlink" title="4. TRANSLATION OF KEYWORD QUERIES TO SPARQL QUERIES"></a>4. TRANSLATION OF KEYWORD QUERIES TO SPARQL QUERIES</h1><h2 id="4-1-Overview-of-the-Translation-Algorithm"><a href="#4-1-Overview-of-the-Translation-Algorithm" class="headerlink" title="4.1 Overview of the Translation Algorithm"></a>4.1 Overview of the Translation Algorithm</h2><p>转化算法接受关键词查询K，RDF数据集T，输出一个SPARQL查询。<br>$G_T$: RDF graph。<br>$D_S$: RDF schema diagram。</p><p>Given a set of metadata matches MM[K,T] and a set of property value matches VM[K,T], we define two functions that group all keywords that match the same class or property:<br><img src="http://ouqbyuben.bkt.clouddn.com/images/EDBT_2017/4.1.jpg"><br><img src="http://ouqbyuben.bkt.clouddn.com/images/EDBT_2017/4.1nucleus.jpg"></p><p>N covers the set of keywords $K<em>n=K_0\cup K_1\cup…\cup K_m\cup K</em>{m+1}\cup …\cup K<em>{m+n}$<br>Given a set of nucleuses $\mathbf N ={N_1,…,N_m}$, we also say that <strong>N</strong> covers $K</em>{N1}\cup …\cup K_{Nm}$.<br>$\mathbf{N_C}$ : the set of classes of the nucleuses in <strong>N</strong>.</p><p>算法共有两个启发式：scoring and minimization。    </p><p>scoring：尝试捕捉用户意图，将关键词列表转换成查询。</p><ul><li>consider how good a match is, say “city” matches “Cities” better than “Sin City”.</li><li>assigns a higher score to metadata matches.</li><li>assigns a higher score to nucleuses that cover a larger number of keywords.</li></ul><p>对于nucleus N=(C,PL,PVL)：<br>$score(N)=(\alpha s<em>C+\beta s_p+(1-\alpha -\beta)s_V$<br>$s_C=meta_sim((K_0,c))$<br>$s_P=\sum</em>{(K<em>i,p_i)\in PL}meta \</em> sim((K<em>i,p_i))$<br>$s_V=\sum</em>{(K<em>j,p_j)\in PVL}value \</em> sim((K_j,p_j))$    </p><p>minimization：尝试生成minimal 答案，共两步。</p><ol><li>实现一个贪婪算法，对由最高分值的nucleuses排序，生成nucleus集合<strong>N</strong>。<ul><li>N covers a large subset of K</li><li>All nodes in $\mathbf{N_C}$ are in the same connected component of $D_S$<br>如果只由N中的nucleus产生答案，查询的得到的connected components可能和$N_C$中的类一样多。</li></ul></li><li>使用$D_S$中的一些边连接$C_N$中的classes强制一个答案只有一个connected component。这和产生以$N_C$中类为节点的斯坦纳树ST等价。然后，该算法使用ST的边来产生SPARQL查询Q的子句，使得Q的任何答案确实具有单个连接的分量。</li></ol><img src="http://ouqbyuben.bkt.clouddn.com/images/EDBT_2017/fig2.jpg">        <p>上图是算法的详细介绍，共有六步：</p><ol><li>去除K中stop words，对剩下部分与T进行匹配，得到MM[K,T]和VM[K,T]。第一步建立了辅助表加速了匹配过程。<ul><li>ClassTable：为S中的类存储IRI，label,description and other property values。</li><li>PropertyTable：存储属性元数据。</li><li>JoinTable：存储S中domains和ranges。</li><li>ValueTable：存储T中distinct property value pair.</li></ul></li><li>使用MM[K,T]和VM[K,T]计算得到a set M of nucleuses.</li><li>为M中的每个nucleus计算得分。</li><li>对应minimization启发式的第一步。把M中最大的核$N_0$从M中取出，放入N。$H_0$为$N_0$的RDF schema上的连通分量。从M中取出所有类不属于$H_0$的核。（为了保证第五步的正确性。）</li><li>实现minimization启发式的第二步。计算覆盖了$N_C$的最小斯坦纳树ST的分时。图中没有写出的详细步骤：首先计算a new labelled directed graph $G_N$ 。其点来自$N_C$，边来自RDF schema diagram $D_S$。然后为$G_N$计算一个最小的有向的spanning tree TN。如果不存在，则计算无向图TN。TN通过将其边替换为$D_S$中对应的路径，得到覆盖$N_C$中节点的$D_S$的斯坦纳树ST。</li><li>合成查询Q使得：<ul><li>Q返回T的子集。</li><li>Q的WHERE子句包含与N中的核的属性值对的元素相对应的过滤器。</li><li>Q的WHERE子句包含与ST中边缘相对应的equijoin子句。</li></ul></li></ol><p>使用引理证明算法的正确性：</p><blockquote><p><strong>Lemma</strong>: Let T be an RDF dataset, S be the RDF schema of T and K be a keyword-based query. Let Q be the SPARQL query the translation algorithm outputs for K,T and S. Then, any result of Q is an answer for K over T with a single connected component.</p></blockquote><h2 id="4-2-An-Example-the-Translation-Process"><a href="#4-2-An-Example-the-Translation-Process" class="headerlink" title="4.2 An Example the Translation Process"></a>4.2 An Example the Translation Process</h2><p>本节阐述算法如何为关键词查询K合成SPARQL查询。<br>流程和上一小节一致，不过举了个例子进行详细说明，此处略。</p><h2 id="4-3-User-Interface"><a href="#4-3-User-Interface" class="headerlink" title="4.3 User Interface"></a>4.3 User Interface</h2><ol><li>提供自动补全功能，基于之前的关键词，RDF schema字典和资源标识符的标签。如fig3a</li><li>利用斯坦纳树和表来展现结果，用户可以选择添加表中的属性。如fig3b，fig3c。</li><li>对比较符号如“&lt;”或预留单词“between”，可以生成简单的过滤器。<img src="http://ouqbyuben.bkt.clouddn.com/images/EDBT_2017/fig3.jpg"><h1 id="5-EXPERIMENTS"><a href="#5-EXPERIMENTS" class="headerlink" title="5. EXPERIMENTS"></a>5. EXPERIMENTS</h1><h2 id="5-1-Experimetn-setup"><a href="#5-1-Experimetn-setup" class="headerlink" title="5.1 Experimetn setup"></a>5.1 Experimetn setup</h2>电脑配置及运行环境~<h2 id="5-2-Experments-with-the-Industrial-Dataset"><a href="#5-2-Experments-with-the-Industrial-Dataset" class="headerlink" title="5.2 Experments with the Industrial Dataset"></a>5.2 Experments with the Industrial Dataset</h2>数据一开始被存储在传统的关系型数据库中，对于metadata matches十分有帮助。我们发现需要得到额外的元数据，如表中那些列是键，那些包含对象的扩展名等，这些对于关键词匹配和如何向用户展现对象等十分重要。操作流程如下：        <ol><li>在关系数据库这边，我们定义了一些列视图来denormalize表。</li><li>创建了一个XML文档对RDF schema中所有别的类和属性进行定义。</li><li>利用该XML文档构建了一个模型生成R2RML声明，帮助关系数据映射到三元组，以及生成4.1节中的辅助表。</li></ol></li></ol><p>（然后贴出部分RFD schema的图，并进行解释）</p><p>数据集属性较多（558个），关于属性的值大部分都是文字，适合关键词查询。<br><img src="http://ouqbyuben.bkt.clouddn.com/images/EDBT_2017/table1.jpg"><br><img src="http://ouqbyuben.bkt.clouddn.com/images/EDBT_2017/table2.jpg"></p><h2 id="5-3-Experiments-with-Mondial-and-IMDb"><a href="#5-3-Experiments-with-Mondial-and-IMDb" class="headerlink" title="5.3 Experiments with Mondial and IMDb"></a>5.3 Experiments with Mondial and IMDb</h2><p>M:32/50<br>IMDb:36/50<br>然后说了一堆， 这个是缺乏关键词语义，关键词描述不准确云云。。</p><h1 id="6-CONCLUSIONS"><a href="#6-CONCLUSIONS" class="headerlink" title="6. CONCLUSIONS"></a>6. CONCLUSIONS</h1><p>总结了一堆功能，这是一个产品的说明并不像一篇科研论文，最后也是强调鲁棒性。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;nucleus&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;ABSTRACT&quot;&gt;&lt;a href=&quot;#ABSTRACT&quot; class=&quot;headerlink&quot; title=&quot;ABSTRACT&quot;&gt;&lt;/a&gt;ABSTRACT&lt;/h1&gt;&lt;p&gt;本文介绍了一个工业项目，其通
      
    
    </summary>
    
      <category term="论文笔记" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="keyword" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/keyword/"/>
    
      <category term="RDF" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/RDF/"/>
    
      <category term="SPARQL" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/SPARQL/"/>
    
      <category term="2017年8月" scheme="https://github.com/LiuKaixin/LiuKaixin.github.io/tags/2017%E5%B9%B48%E6%9C%88/"/>
    
  </entry>
  
</feed>
